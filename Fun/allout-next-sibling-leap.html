---
title: "allout-next-sibling-leap"
layout: doc
---
<strong>allout-next-sibling-leap</strong> is a compiled Lisp function in `<code>allout.el</code>'.</br>
</br>
(allout-next-sibling-leap &optional <u>DEPTH</u> <u>BACKWARD</u>)</br>
</br>
Like `allout-next-sibling', but by direct search for topic at depth.</br>
</br>
Traverse at optional <u>DEPTH</u>, or current depth if none specified.</br>
</br>
Go backward if optional arg <u>BACKWARD</u> is non-nil.</br>
</br>
Return the start point of the new topic if successful, nil otherwise.</br>
</br>
Costs more than regular `allout-next-sibling' for short traversals:</br>
</br>
 - we have to check the prior (next, if traveling backwards)</br>
   item to confirm connectivity with the prior topic, and</br>
 - if confirmed, we have to reestablish the allout-recent-* settings with</br>
   some extra navigation</br>
 - if confirmation fails, we have to do more work to recover</br>
</br>
It is an increasingly big win when there are many intervening</br>
offspring before the next sibling, however, so</br>
`allout-next-sibling' resorts to this if it finds itself in that</br>
situation.
