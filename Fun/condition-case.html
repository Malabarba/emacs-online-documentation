<strong>condition-case</strong> is a special form in `<code>C source code</code>'.</br>
</br>
(condition-case <u>VAR</u> <u>BODYFORM</u> &rest <u>HANDLERS</u>)</br>
</br>
Regain control when an error is signaled.</br>
Executes <u>BODYFORM</u> and returns its value if no error happens.</br>
Each element of <u>HANDLERS</u> looks like (CONDITION-NAME BODY...)</br>
where the BODY is made of Lisp expressions.</br>
</br>
A handler is applicable to an error</br>
if CONDITION-NAME is one of the error's condition names.</br>
If an error happens, the first applicable handler is run.</br>
</br>
The car of a handler may be a list of condition names instead of a</br>
single condition name; then it handles all of them.  If the special</br>
condition name `debug' is present in this list, it allows another</br>
condition in the list to run the debugger if `debug-on-error' and the</br>
other usual mechanisms says it should (otherwise, `condition-case'</br>
suppresses the debugger).</br>
</br>
When a handler handles an error, control returns to the `condition-case'</br>
and it executes the handler's BODY...</br>
with <u>VAR</u> bound to (ERROR-SYMBOL . SIGNAL-DATA) from the error.</br>
(If <u>VAR</u> is nil, the handler can't access that information.)</br>
Then the value of the last BODY form is returned from the `condition-case'</br>
expression.</br>
</br>
See also the function `signal' for more info.