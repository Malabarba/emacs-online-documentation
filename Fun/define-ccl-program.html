<strong>define-ccl-program</strong> is an autoloaded Lisp macro in `<code>ccl.el</code>'.<br/>
<br/>
(define-ccl-program NAME CCL-PROGRAM &optional DOC)<br/>
<br/>
Set NAME the compiled code of CCL-PROGRAM.<br/>
<br/>
CCL-PROGRAM has this form:<br/>
	(BUFFER_MAGNIFICATION<br/>
	 CCL_MAIN_CODE<br/>
	 [ CCL_EOF_CODE ])<br/>
<br/>
BUFFER_MAGNIFICATION is an integer value specifying the approximate<br/>
output buffer magnification size compared with the bytes of input data<br/>
text.  It is assured that the actual output buffer has 256 bytes<br/>
more than the size calculated by BUFFER_MAGNIFICATION.<br/>
If the value is zero, the CCL program can't execute `read' and<br/>
`write' commands.<br/>
<br/>
CCL_MAIN_CODE and CCL_EOF_CODE are CCL program codes.  CCL_MAIN_CODE<br/>
executed at first.  If there's no more input data when `read' command<br/>
is executed in CCL_MAIN_CODE, CCL_EOF_CODE is executed.  If<br/>
CCL_MAIN_CODE is terminated, CCL_EOF_CODE is not executed.<br/>
<br/>
Here's the syntax of CCL program code in BNF notation.  The lines<br/>
starting by two semicolons (and optional leading spaces) describe the<br/>
semantics.<br/>
<br/>
CCL_MAIN_CODE := CCL_BLOCK<br/>
<br/>
CCL_EOF_CODE := CCL_BLOCK<br/>
<br/>
CCL_BLOCK := STATEMENT | (STATEMENT [STATEMENT ...])<br/>
<br/>
STATEMENT :=<br/>
	SET | IF | BRANCH | LOOP | REPEAT | BREAK | READ | WRITE | CALL<br/>
	| TRANSLATE | MAP | LOOKUP | END<br/>
<br/>
SET :=	(REG = EXPRESSION)<br/>
	| (REG ASSIGNMENT_OPERATOR EXPRESSION)<br/>
	;; The following form is the same as (r0 = integer).<br/>
	| integer<br/>
<br/>
EXPRESSION := ARG | (EXPRESSION OPERATOR ARG)<br/>
<br/>
;; Evaluate EXPRESSION.  If the result is nonzero, execute<br/>
;; CCL_BLOCK_0.  Otherwise, execute CCL_BLOCK_1.<br/>
IF :=	(if EXPRESSION CCL_BLOCK_0 CCL_BLOCK_1)<br/>
<br/>
;; Evaluate EXPRESSION.  Provided that the result is N, execute<br/>
;; CCL_BLOCK_N.<br/>
BRANCH := (branch EXPRESSION CCL_BLOCK_0 [CCL_BLOCK_1 ...])<br/>
<br/>
;; Execute STATEMENTs until (break) or (end) is executed.<br/>
LOOP := (loop STATEMENT [STATEMENT ...])<br/>
<br/>
;; Terminate the most inner loop.<br/>
BREAK := (break)<br/>
<br/>
REPEAT :=<br/>
	;; Jump to the head of the most inner loop.<br/>
	(repeat)<br/>
	;; Same as: ((write [REG | integer | string])<br/>
	;;	     (repeat))<br/>
	| (write-repeat [REG | integer | string])<br/>
	;; Same as: ((write REG [ARRAY])<br/>
	;;	     (read REG)<br/>
	;;	     (repeat))<br/>
	| (write-read-repeat REG [ARRAY])<br/>
	;; Same as: ((write integer)<br/>
	;;	     (read REG)<br/>
	;;	     (repeat))<br/>
	| (write-read-repeat REG integer)<br/>
<br/>
READ := ;; Set REG_0 to a byte read from the input text, set REG_1<br/>
	;; to the next byte read, and so on.<br/>
	(read REG_0 [REG_1 ...])<br/>
	;; Same as: ((read REG)<br/>
	;;	     (if (REG OPERATOR ARG) CCL_BLOCK_0 CCL_BLOCK_1))<br/>
	| (read-if (REG OPERATOR ARG) CCL_BLOCK_0 CCL_BLOCK_1)<br/>
	;; Same as: ((read REG)<br/>
	;;	     (branch REG CCL_BLOCK_0 [CCL_BLOCK_1 ...]))<br/>
	| (read-branch REG CCL_BLOCK_0 [CCL_BLOCK_1 ...])<br/>
	;; Read a character from the input text while parsing<br/>
	;; multibyte representation, set REG_0 to the charset ID of<br/>
	;; the character, set REG_1 to the code point of the<br/>
	;; character.  If the dimension of charset is two, set REG_1<br/>
	;; to ((CODE0 << 7) | CODE1), where CODE0 is the first code<br/>
	;; point and CODE1 is the second code point.<br/>
	| (read-multibyte-character REG_0 REG_1)<br/>
<br/>
WRITE :=<br/>
	;; Write REG_0, REG_1, ... to the output buffer.  If REG_N is<br/>
	;; a multibyte character, write the corresponding multibyte<br/>
	;; representation.<br/>
	(write REG_0 [REG_1 ...])<br/>
	;; Same as: ((r7 = EXPRESSION)<br/>
	;;	     (write r7))<br/>
	| (write EXPRESSION)<br/>
	;; Write the value of `integer' to the output buffer.  If it<br/>
	;; is a multibyte character, write the corresponding multibyte<br/>
	;; representation.<br/>
	| (write integer)<br/>
	;; Write the byte sequence of `string' as is to the output<br/>
	;; buffer.<br/>
	| (write string)<br/>
	;; Same as: (write string)<br/>
	| string<br/>
	;; Provided that the value of REG is N, write Nth element of<br/>
	;; ARRAY to the output buffer.  If it is a multibyte<br/>
	;; character, write the corresponding multibyte<br/>
	;; representation.<br/>
	| (write REG ARRAY)<br/>
	;; Write a multibyte representation of a character whose<br/>
	;; charset ID is REG_0 and code point is REG_1.  If the<br/>
	;; dimension of the charset is two, REG_1 should be ((CODE0 <<<br/>
	;; 7) | CODE1), where CODE0 is the first code point and CODE1<br/>
	;; is the second code point of the character.<br/>
	| (write-multibyte-character REG_0 REG_1)<br/>
<br/>
;; Call CCL program whose name is ccl-program-name.<br/>
CALL := (call ccl-program-name)<br/>
<br/>
;; Terminate the CCL program.<br/>
END := (end)<br/>
<br/>
;; CCL registers that can contain any integer value.  As r7 is also<br/>
;; used by CCL interpreter, its value is changed unexpectedly.<br/>
REG := r0 | r1 | r2 | r3 | r4 | r5 | r6 | r7<br/>
<br/>
ARG := REG | integer<br/>
<br/>
OPERATOR :=<br/>
	;; Normal arithmetic operators (same meaning as C code).<br/>
	+ | - | * | / | %<br/>
<br/>
	;; Bitwise operators (same meaning as C code)<br/>
	| & | `|' | ^<br/>
<br/>
	;; Shifting operators (same meaning as C code)<br/>
	| << | >><br/>
<br/>
	;; (REG = ARG_0 <8 ARG_1) means:<br/>
	;;	(REG = ((ARG_0 << 8) | ARG_1))<br/>
	| <8<br/>
<br/>
	;; (REG = ARG_0 >8 ARG_1) means:<br/>
	;;	((REG = (ARG_0 >> 8))<br/>
	;;	 (r7 = (ARG_0 & 255)))<br/>
	| >8<br/>
<br/>
	;; (REG = ARG_0 // ARG_1) means:<br/>
	;;	((REG = (ARG_0 / ARG_1))<br/>
	;;	 (r7 = (ARG_0 % ARG_1)))<br/>
	| //<br/>
<br/>
	;; Normal comparing operators (same meaning as C code)<br/>
	| < | > | == | <= | >= | !=<br/>
<br/>
	;; If ARG_0 and ARG_1 are higher and lower byte of Shift-JIS<br/>
	;; code, and CHAR is the corresponding JISX0208 character,<br/>
	;; (REG = ARG_0 de-sjis ARG_1) means:<br/>
	;;	((REG = CODE0)<br/>
	;;	 (r7 = CODE1))<br/>
	;; where CODE0 is the first code point of CHAR, CODE1 is the<br/>
	;; second code point of CHAR.<br/>
	| de-sjis<br/>
<br/>
	;; If ARG_0 and ARG_1 are the first and second code point of<br/>
	;; JISX0208 character CHAR, and SJIS is the corresponding<br/>
	;; Shift-JIS code,<br/>
	;; (REG = ARG_0 en-sjis ARG_1) means:<br/>
	;;	((REG = HIGH)<br/>
	;;	 (r7 = LOW))<br/>
	;; where HIGH is the higher byte of SJIS, LOW is the lower<br/>
	;; byte of SJIS.<br/>
	| en-sjis<br/>
<br/>
ASSIGNMENT_OPERATOR :=<br/>
	;; Same meaning as C code<br/>
	+= | -= | *= | /= | %= | &= | `|=' | ^= | <<= | >>=<br/>
<br/>
	;; (REG <8= ARG) is the same as:<br/>
	;;	((REG <<= 8)<br/>
	;;	 (REG |= ARG))<br/>
	| <8=<br/>
<br/>
	;; (REG >8= ARG) is the same as:<br/>
	;;	((r7 = (REG & 255))<br/>
	;;	 (REG >>= 8))<br/>
<br/>
	;; (REG //= ARG) is the same as:<br/>
	;;	((r7 = (REG % ARG))<br/>
	;;	 (REG /= ARG))<br/>
	| //=<br/>
<br/>
ARRAY := `[' integer ... `]'<br/>
<br/>
<br/>
TRANSLATE :=<br/>
	(translate-character REG(table) REG(charset) REG(codepoint))<br/>
	| (translate-character SYMBOL REG(charset) REG(codepoint))<br/>
        ;; SYMBOL must refer to a table defined by `define-translation-table'.<br/>
LOOKUP :=<br/>
	(lookup-character SYMBOL REG(charset) REG(codepoint))<br/>
	| (lookup-integer SYMBOL REG(integer))<br/>
        ;; SYMBOL refers to a table defined by `define-translation-hash-table'.<br/>
MAP :=<br/>
     (iterate-multiple-map REG REG MAP-IDs)<br/>
     | (map-multiple REG REG (MAP-SET))<br/>
     | (map-single REG REG MAP-ID)<br/>
MAP-IDs := MAP-ID ...<br/>
MAP-SET := MAP-IDs | (MAP-IDs) MAP-SET<br/>
MAP-ID := integer