<strong>interactive</strong> is a special form in `<code>C source code</code>'.<br/>
<br/>
(interactive &optional ARGS)<br/>
<br/>
Specify a way of parsing arguments for interactive use of a function.<br/>
For example, write<br/>
 (defun foo (arg buf) "Doc string" (interactive "P\nbbuffer: ") .... )<br/>
 to make ARG be the raw prefix argument, and set BUF to an existing buffer,<br/>
 when `foo' is called as a command.<br/>
The "call" to `interactive' is actually a declaration rather than a function;<br/>
 it tells `call-interactively' how to read arguments<br/>
 to pass to the function.<br/>
When actually called, `interactive' just returns nil.<br/>
<br/>
Usually the argument of `interactive' is a string containing a code letter<br/>
 followed optionally by a prompt.  (Some code letters do not use I/O to get<br/>
 the argument and do not use prompts.)  To get several arguments, concatenate<br/>
 the individual strings, separating them by newline characters.<br/>
Prompts are passed to format, and may use % escapes to print the<br/>
 arguments that have already been read.<br/>
If the argument is not a string, it is evaluated to get a list of<br/>
 arguments to pass to the function.<br/>
Just `(interactive)' means pass no args when calling interactively.<br/>
<br/>
Code letters available are:<br/>
a -- Function name: symbol with a function definition.<br/>
b -- Name of existing buffer.<br/>
B -- Name of buffer, possibly nonexistent.<br/>
c -- Character (no input method is used).<br/>
C -- Command name: symbol with interactive function definition.<br/>
d -- Value of point as number.  Does not do I/O.<br/>
D -- Directory name.<br/>
e -- Parameterized event (i.e., one that's a list) that invoked this command.<br/>
     If used more than once, the Nth `e' returns the Nth parameterized event.<br/>
     This skips events that are integers or symbols.<br/>
f -- Existing file name.<br/>
F -- Possibly nonexistent file name.<br/>
G -- Possibly nonexistent file name, defaulting to just directory name.<br/>
i -- Ignored, i.e. always nil.  Does not do I/O.<br/>
k -- Key sequence (downcase the last event if needed to get a definition).<br/>
K -- Key sequence to be redefined (do not downcase the last event).<br/>
m -- Value of mark as number.  Does not do I/O.<br/>
M -- Any string.  Inherits the current input method.<br/>
n -- Number read using minibuffer.<br/>
N -- Numeric prefix arg, or if none, do like code `n'.<br/>
p -- Prefix arg converted to number.  Does not do I/O.<br/>
P -- Prefix arg in raw form.  Does not do I/O.<br/>
r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.<br/>
s -- Any string.  Does not inherit the current input method.<br/>
S -- Any symbol.<br/>
U -- Mouse up event discarded by a previous k or K argument.<br/>
v -- Variable name: symbol that is `custom-variable-p'.<br/>
x -- Lisp expression read but not evaluated.<br/>
X -- Lisp expression read and evaluated.<br/>
z -- Coding system.<br/>
Z -- Coding system, nil if no prefix arg.<br/>
<br/>
In addition, if the string begins with `*', an error is signaled if<br/>
  the buffer is read-only.<br/>
If `@' appears at the beginning of the string, and if the key sequence<br/>
 used to invoke the command includes any mouse events, then the window<br/>
 associated with the first of those events is selected before the<br/>
 command is run.<br/>
If the string begins with `^' and `shift-select-mode' is non-nil,<br/>
 Emacs first calls the function `handle-shift-selection'.<br/>
You may use `@', `*', and `^' together.  They are processed in the<br/>
 order that they appear, before reading any arguments.