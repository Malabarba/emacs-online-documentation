pcomplete-here is a Lisp macro in `pcomplete.el'.<br/><br/>(pcomplete-here &optional FORM STUB PARING FORM-ONLY)<br/><br/>Complete against the current argument, if at the end.<br/>If completion is to be done here, evaluate FORM to generate the completion<br/>table which will be used for completion purposes.  If STUB is a<br/>string, use it as the completion stub instead of the default (which is<br/>the entire text of the current argument).<br/><br/>For an example of when you might want to use STUB: if the current<br/>argument text is 'long-path-name/', you don't want the completions<br/>list display to be cluttered by 'long-path-name/' appearing at the<br/>beginning of every alternative.  Not only does this make things less<br/>intelligible, but it is also inefficient.  Yet, if the completion list<br/>does not begin with this string for every entry, the current argument<br/>won't complete correctly.<br/><br/>The solution is to specify a relative stub.  It allows you to<br/>substitute a different argument from the current argument, almost<br/>always for the sake of efficiency.<br/><br/>If PARING is nil, this argument will be pared against previous<br/>arguments using the function `file-truename' to normalize them.<br/>PARING may be a function, in which case that function is used for<br/>normalization.  If PARING is t, the argument dealt with by this<br/>call will not participate in argument paring.  If it is the<br/>integer 0, all previous arguments that have been seen will be<br/>cleared.<br/><br/>If FORM-ONLY is non-nil, only the result of FORM will be used to<br/>generate the completions list.  This means that the hook<br/>`pcomplete-try-first-hook' will not be run.