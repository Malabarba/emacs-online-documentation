<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head><style type="text/css"> @import url('http://www.gnu.org/software/emacs/manual.css');</style></head><body style="padding:1rem;"><strong>query-replace-regexp</strong> is an interactive compiled Lisp function in `<code>replace.el</code>'.</br>
</br>
It is bound to C-M-%, &lt;menu-bar> &lt;edit> &lt;replace> &lt;query-replace-regexp>.</br>
</br>
<code>(query-replace-regexp <u>REGEXP</u> <u>TO-STRING</u> <em>&optional</em> <u>DELIMITED</u> <u>START</u> <u>END</u> <u>BACKWARD</u></code>)</br>
</br>
Replace some things after point matching <u>REGEXP</u> with <u>TO-STRING</u>.</br>
As each match is found, the user must type a character saying</br>
what to do with it.  For directions, type C-h at that time.</br>
</br>
In Transient Mark mode, if the mark is active, operate on the contents</br>
of the region.  Otherwise, operate from point to the end of the buffer.</br>
</br>
Use M-n to pull the last incremental search regexp to the minibuffer</br>
that reads <u>REGEXP</u>, or invoke replacements from</br>
incremental search with a key sequence like `C-M-s C-M-s C-M-%'</br>
to use its current search regexp as the regexp to replace.</br>
</br>
Matching is independent of case if `case-fold-search' is non-nil and</br>
<u>REGEXP</u> has no uppercase letters.  Replacement transfers the case</br>
pattern of the old text to the new text, if `case-replace' and</br>
`case-fold-search' are non-nil and <u>REGEXP</u> has no uppercase letters.</br>
(Transferring the case pattern means that if the old text matched is</br>
all caps, or capitalized, then its replacement is upcased or</br>
capitalized.)</br>
</br>
Ignore read-only matches if `query-replace-skip-read-only' is non-nil,</br>
ignore hidden matches if `search-invisible' is nil, and ignore more</br>
matches using `isearch-filter-predicate'.</br>
</br>
If `replace-regexp-lax-whitespace' is non-nil, a space or spaces in the regexp</br>
to be replaced will match a sequence of whitespace chars defined by the</br>
regexp in `search-whitespace-regexp'.</br>
</br>
Third arg <u>DELIMITED</u> (prefix arg if interactive), if non-nil, means replace</br>
only matches surrounded by word boundaries.  A negative prefix arg means</br>
replace backward.</br>
</br>
Fourth and fifth arg <u>START</u> and <u>END</u> specify the region to operate on.</br>
</br>
In <u>TO-STRING</u>, `\&' stands for whatever matched the whole of <u>REGEXP</u>,</br>
and `\N' (where N is a digit) stands for</br>
whatever what matched the Nth `\(...\)' in <u>REGEXP</u>.</br>
`\?' lets you edit the replacement text in the minibuffer</br>
at the given position for each replacement.</br>
</br>
In interactive calls, the replacement text can contain `\,'</br>
followed by a Lisp expression.  Each</br>
replacement evaluates that expression to compute the replacement</br>
string.  Inside of that expression, `\&' is a string denoting the</br>
whole match as a string, `\N' for a partial match, `\#&' and `\#N'</br>
for the whole or a partial match converted to a number with</br>
`string-to-number', and `\#' itself for the number of replacements</br>
done so far (starting with zero).</br>
</br>
If the replacement expression is a symbol, write a space after it</br>
to terminate it.  One space there, if any, will be discarded.</br>
</br>
When using those Lisp features interactively in the replacement</br>
text, <u>TO-STRING</u> is actually made a list instead of a string.</br>
Use C-x M-: after this command for details.<br/><br/><br/><br/><small>A courtesy of <a href="http://endlessparentheses.com/">Endless Parentheses</a>.</small></body></html>
