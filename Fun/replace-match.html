---
title: "replace-match"
layout: doc
---
<strong>replace-match</strong> is a built-in function in `<code>C source code</code>'.</br>
</br>
(replace-match <u>NEWTEXT</u> &optional <u>FIXEDCASE</u> <u>LITERAL</u> <u>STRING</u> <u>SUBEXP</u>)</br>
</br>
Replace text matched by last search with <u>NEWTEXT</u>.</br>
Leave point at the end of the replacement text.</br>
</br>
If optional second arg <u>FIXEDCASE</u> is non-nil, do not alter the case of</br>
the replacement text.  Otherwise, maybe capitalize the whole text, or</br>
maybe just word initials, based on the replaced text.  If the replaced</br>
text has only capital letters and has at least one multiletter word,</br>
convert <u>NEWTEXT</u> to all caps.  Otherwise if all words are capitalized</br>
in the replaced text, capitalize each word in <u>NEWTEXT</u>.</br>
</br>
If optional third arg <u>LITERAL</u> is non-nil, insert <u>NEWTEXT</u> literally.</br>
Otherwise treat `\' as special:</br>
  `\&' in <u>NEWTEXT</u> means substitute original matched text.</br>
  `\N' means substitute what matched the Nth `\(...\)'.</br>
       If Nth parens didn't match, substitute nothing.</br>
  `\\' means insert one `\'.</br>
  `\?' is treated literally</br>
       (for compatibility with `query-replace-regexp').</br>
  Any other character following `\' signals an error.</br>
Case conversion does not apply to these substitutions.</br>
</br>
If optional fourth argument <u>STRING</u> is non-nil, it should be a string</br>
to act on; this should be the string on which the previous match was</br>
done via `string-match'.  In this case, `replace-match' creates and</br>
returns a new string, made by copying <u>STRING</u> and replacing the part of</br>
<u>STRING</u> that was matched (the original <u>STRING</u> itself is not altered).</br>
</br>
The optional fifth argument <u>SUBEXP</u> specifies a subexpression;</br>
it says to replace just that subexpression with <u>NEWTEXT</u>,</br>
rather than replacing the entire matched text.</br>
This is, in a vague sense, the inverse of using `\N' in <u>NEWTEXT</u>;</br>
`\N' copies subexp N into <u>NEWTEXT</u>, but using N as <u>SUBEXP</u> puts</br>
<u>NEWTEXT</u> in place of subexp N.</br>
This is useful only after a regular expression search or match,</br>
since only regular expressions have distinguished subexpressions.
