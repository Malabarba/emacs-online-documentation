---
title: "replace-regexp"
layout: doc
---
<strong>replace-regexp</strong> is an interactive compiled Lisp function in `<code>replace.el</code>'.</br>
</br>
</br>
(replace-regexp <u>REGEXP</u> <u>TO-STRING</u> &optional <u>DELIMITED</u> <u>START</u> <u>END</u> <u>BACKWARD</u>)</br>
</br>
This function is for interactive use only;</br>
in Lisp code use `re-search-forward' and `replace-match' instead.</br>
</br>
Replace things after point matching <u>REGEXP</u> with <u>TO-STRING</u>.</br>
Preserve case in each match if `case-replace' and `case-fold-search'</br>
are non-nil and <u>REGEXP</u> has no uppercase letters.</br>
</br>
Ignore read-only matches if `query-replace-skip-read-only' is non-nil,</br>
ignore hidden matches if `search-invisible' is nil, and ignore more</br>
matches using `isearch-filter-predicate'.</br>
</br>
If `replace-regexp-lax-whitespace' is non-nil, a space or spaces in the regexp</br>
to be replaced will match a sequence of whitespace chars defined by the</br>
regexp in `search-whitespace-regexp'.</br>
</br>
In Transient Mark mode, if the mark is active, operate on the contents</br>
of the region.  Otherwise, operate from point to the end of the buffer.</br>
</br>
Third arg <u>DELIMITED</u> (prefix arg if interactive), if non-nil, means replace</br>
only matches surrounded by word boundaries.  A negative prefix arg means</br>
replace backward.</br>
</br>
Fourth and fifth arg <u>START</u> and <u>END</u> specify the region to operate on.</br>
</br>
In <u>TO-STRING</u>, `\&' stands for whatever matched the whole of <u>REGEXP</u>,</br>
and `\N' (where N is a digit) stands for</br>
whatever what matched the Nth `\(...\)' in <u>REGEXP</u>.</br>
`\?' lets you edit the replacement text in the minibuffer</br>
at the given position for each replacement.</br>
</br>
In interactive calls, the replacement text may contain `\,'</br>
followed by a Lisp expression used as part of the replacement</br>
text.  Inside of that expression, `\&' is a string denoting the</br>
whole match, `\N' a partial match, `\#&' and `\#N' the respective</br>
numeric values from `string-to-number', and `\#' itself for</br>
`replace-count', the number of replacements occurred so far.</br>
</br>
If your Lisp expression is an identifier and the next letter in</br>
the replacement string would be interpreted as part of it, you</br>
can wrap it with an expression like `\,(or \#)'.  Incidentally,</br>
for this particular case you may also enter `\#' in the</br>
replacement text directly.</br>
</br>
When using those Lisp features interactively in the replacement</br>
text, <u>TO-STRING</u> is actually made a list instead of a string.</br>
Use C-x M-: after this command for details.</br>
</br>
Use M-n to pull the last incremental search regexp to the minibuffer</br>
that reads <u>REGEXP</u>.</br>
</br>
This function is usually the wrong thing to use in a Lisp program.</br>
What you probably want is a loop like this:</br>
  (while (re-search-forward <u>REGEXP</u> nil t)</br>
    (replace-match <u>TO-STRING</u> nil nil))</br>
which will run faster and will not set the mark or print anything.
