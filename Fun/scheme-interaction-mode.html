<strong>scheme-interaction-mode</strong> is an interactive compiled Lisp function in `<code>xscheme.el</code>'.<br/>
<br/>
(scheme-interaction-mode &optional PRESERVE)<br/>
<br/>
Major mode for interacting with an inferior MIT Scheme process.<br/>
Like  scheme-mode  except that:<br/>
<br/>
M-x xscheme-send-previous-expression sends the expression before point to the Scheme process as input<br/>
M-x xscheme-yank-pop yanks an expression previously sent to Scheme<br/>
M-x xscheme-yank-push yanks an expression more recently sent to Scheme<br/>
<br/>
All output from the Scheme process is written in the Scheme process<br/>
buffer, which is initially named "*scheme*".  The result of<br/>
evaluating a Scheme expression is also printed in the process buffer,<br/>
preceded by the string ";Value: " to highlight it.  If the process<br/>
buffer is not visible at that time, the value will also be displayed<br/>
in the minibuffer.  If an error occurs, the process buffer will<br/>
automatically pop up to show you the error message.<br/>
<br/>
While the Scheme process is running, the mode lines of all buffers in<br/>
scheme-mode are modified to show the state of the process.  The<br/>
possible states and their meanings are:<br/>
<br/>
input		waiting for input<br/>
run		evaluating<br/>
gc		garbage collecting<br/>
<br/>
The process buffer's mode line contains additional information where<br/>
the buffer's name is normally displayed: the command interpreter level<br/>
and type.<br/>
<br/>
Scheme maintains a stack of command interpreters.  Every time an error<br/>
or breakpoint occurs, the current command interpreter is pushed on the<br/>
command interpreter stack, and a new command interpreter is started.<br/>
One example of why this is done is so that an error that occurs while<br/>
you are debugging another error will not destroy the state of the<br/>
initial error, allowing you to return to it after the second error has<br/>
been fixed.<br/>
<br/>
The command interpreter level indicates how many interpreters are in<br/>
the command interpreter stack.  It is initially set to one, and it is<br/>
incremented every time that stack is pushed, and decremented every<br/>
time it is popped.  The following commands are useful for manipulating<br/>
the command interpreter stack:<br/>
<br/>
M-x xscheme-send-breakpoint-interrupt	pushes the stack once<br/>
M-x xscheme-send-control-u-interrupt	pops the stack once<br/>
M-x xscheme-send-control-g-interrupt	pops everything off<br/>
M-x xscheme-send-control-x-interrupt	aborts evaluation, doesn't affect stack<br/>
<br/>
Some possible command interpreter types and their meanings are:<br/>
<br/>
[Evaluator]	read-eval-print loop for evaluating expressions<br/>
[Debugger]	single character commands for debugging errors<br/>
[Where]		single character commands for examining environments<br/>
<br/>
Starting with release 6.2 of Scheme, the latter two types of command<br/>
interpreters will change the major mode of the Scheme process buffer<br/>
to scheme-debugger-mode , in which the evaluation commands are<br/>
disabled, and the keys which normally self insert instead send<br/>
themselves to the Scheme process.  The command character ? will list<br/>
the available commands.<br/>
<br/>
For older releases of Scheme, the major mode will be be<br/>
scheme-interaction-mode , and the command characters must be sent as<br/>
if they were expressions.<br/>
<br/>
Commands:<br/>
Delete converts tabs to spaces as it moves back.<br/>
Blank lines separate paragraphs.  Semicolons start comments.<br/>
key             binding<br/>
---             -------<br/>
<br/>
C-c		Prefix Command<br/>
C-x		Prefix Command<br/>
ESC		Prefix Command<br/>
DEL		backward-delete-char-untabify<br/>
<br/>
C-c C-b		xscheme-send-breakpoint-interrupt<br/>
C-c C-c		xscheme-send-control-g-interrupt<br/>
C-c RET		xscheme-send-current-line<br/>
C-c C-o		xscheme-delete-output<br/>
C-c C-p		xscheme-send-proceed<br/>
C-c C-s		xscheme-select-process-buffer<br/>
C-c C-u		xscheme-send-control-u-interrupt<br/>
C-c C-x		xscheme-send-control-x-interrupt<br/>
C-c C-y		xscheme-yank<br/>
<br/>
C-x C-e		xscheme-send-previous-expression<br/>
<br/>
M-RET		xscheme-send-previous-expression<br/>
C-M-q		indent-sexp<br/>
C-M-x		xscheme-send-definition<br/>
C-M-z		xscheme-send-region<br/>
M-n		xscheme-yank-push<br/>
M-o		xscheme-send-buffer<br/>
M-p		xscheme-yank-pop<br/>
M-z		xscheme-send-definition<br/>
<br/>
<br/>
<br/>
Entry to this mode calls the value of scheme-interaction-mode-hook<br/>
with no args, if that value is non-nil.<br/>
 Likewise with the value of scheme-mode-hook.<br/>
 scheme-interaction-mode-hook is called after scheme-mode-hook.