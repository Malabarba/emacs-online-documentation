---
title: "shell-command"
layout: doc
---
<strong>shell-command</strong> is an interactive compiled Lisp function in `<code>simple.el</code>'.</br>
</br>
It is bound to M-!, &lt;menu-bar> &lt;tools> &lt;shell>.</br>
</br>
<code>(shell-command <u>COMMAND</u> <em>&optional</em> <u>OUTPUT-BUFFER</u> <u>ERROR-BUFFER</u></code>)</br>
</br>
Execute string <u>COMMAND</u> in inferior shell; display output, if any.</br>
With prefix argument, insert the <u>COMMAND</u>'s output at point.</br>
</br>
If <u>COMMAND</u> ends in `&', execute it asynchronously.</br>
The output appears in the buffer `*Async Shell Command*'.</br>
That buffer is in shell mode.  You can also use</br>
`async-shell-command' that automatically adds `&'.</br>
</br>
Otherwise, <u>COMMAND</u> is executed synchronously.  The output appears in</br>
the buffer `*Shell Command Output*'.  If the output is short enough to</br>
display in the echo area (which is determined by the variables</br>
`resize-mini-windows' and `max-mini-window-height'), it is shown</br>
there, but it is nonetheless available in buffer `*Shell Command</br>
Output*' even though that buffer is not automatically displayed.</br>
</br>
To specify a coding system for converting non-ASCII characters</br>
in the shell command output, use C-x RET c before this command.</br>
</br>
Noninteractive callers can specify coding systems by binding</br>
`coding-system-for-read' and `coding-system-for-write'.</br>
</br>
The optional second argument <u>OUTPUT-BUFFER</u>, if non-nil,</br>
says to put the output in some other buffer.</br>
If <u>OUTPUT-BUFFER</u> is a buffer or buffer name, put the output there.</br>
If <u>OUTPUT-BUFFER</u> is not a buffer and not nil,</br>
insert output in current buffer.  (This cannot be done asynchronously.)</br>
In either case, the buffer is first erased, and the output is</br>
inserted after point (leaving mark after it).</br>
</br>
If the command terminates without error, but generates output,</br>
and you did not specify "insert it in the current buffer",</br>
the output can be displayed in the echo area or in its buffer.</br>
If the output is short enough to display in the echo area</br>
(determined by the variable `max-mini-window-height' if</br>
`resize-mini-windows' is non-nil), it is shown there.</br>
Otherwise,the buffer containing the output is displayed.</br>
</br>
If there is output and an error, and you did not specify "insert it</br>
in the current buffer", a message about the error goes at the end</br>
of the output.</br>
</br>
If there is no output, or if output is inserted in the current buffer,</br>
then `*Shell Command Output*' is deleted.</br>
</br>
If the optional third argument <u>ERROR-BUFFER</u> is non-nil, it is a buffer</br>
or buffer name to which to direct the command's standard error output.</br>
If it is nil, error output is mingled with regular output.</br>
In an interactive call, the variable `shell-command-default-error-buffer'</br>
specifies the value of <u>ERROR-BUFFER</u>.</br>
</br>
In Elisp, you will often be better served by calling `call-process' or</br>
`start-process' directly, since it offers more control and does not impose</br>
the use of a shell (with its need to quote arguments).
