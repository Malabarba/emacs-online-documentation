---
title: "verilog-auto-reset"
layout: doc
---
<strong>verilog-auto-reset</strong> is an interactive compiled Lisp function in `<code>verilog-mode.el</code>'.</br>
</br>
</br>
(verilog-auto-reset)</br>
</br>
Expand AUTORESET statements, as part of M-x verilog-auto.</br>
Replace the /*AUTORESET*/ comment with code to initialize all</br>
registers set elsewhere in the always block.</br>
</br>
Limitations:</br>
  AUTORESET will not clear memories.</br>
</br>
  AUTORESET uses &lt;= if the signal has a &lt;= assignment in the block,</br>
  else it uses =.</br>
</br>
  If &lt;= is used, all = assigned variables are ignored if</br>
  `verilog-auto-reset-blocking-in-non' is nil; they are presumed</br>
  to be temporaries.</br>
</br>
/*AUTORESET*/ presumes that any signals mentioned between the previous</br>
begin/case/if statement and the AUTORESET comment are being reset manually</br>
and should not be automatically reset.  This includes omitting any signals</br>
used on the right hand side of assignments.</br>
</br>
By default, AUTORESET will include the width of the signal in the</br>
autos, SystemVerilog designs may want to change this.  To control</br>
this behavior, see `verilog-auto-reset-widths'.  In some cases</br>
AUTORESET must use a '0 assignment and it will print NOWIDTH; use</br>
`verilog-auto-reset-widths' unbased to prevent this.</br>
</br>
AUTORESET ties signals to deasserted, which is presumed to be zero.</br>
Signals that match `verilog-active-low-regexp' will be deasserted by tying</br>
them to a one.</br>
</br>
AUTORESET may try to reset arrays or structures that cannot be</br>
reset by a simple assignment, resulting in compile errors.  This</br>
is a feature to be taken as a hint that you need to reset these</br>
signals manually (or put them into a "`ifdef NEVER signal&lt;=`0;</br>
`endif" so Verilog-Mode ignores them.)</br>
</br>
An example:</br>
</br>
    always @(posedge clk or negedge reset_l) begin</br>
        if (!reset_l) begin</br>
            c &lt;= 1;</br>
            /*AUTORESET*/</br>
        end</br>
        else begin</br>
            a &lt;= in_a;</br>
            b &lt;= in_b;</br>
            c &lt;= in_c;</br>
        end</br>
    end</br>
</br>
Typing M-x verilog-auto will make this into:</br>
</br>
    always @(posedge core_clk or negedge reset_l) begin</br>
        if (!reset_l) begin</br>
            c &lt;= 1;</br>
            /*AUTORESET*/</br>
            // Beginning of autoreset for uninitialized flops</br>
            a &lt;= 0;</br>
            b = 0;   // if `verilog-auto-reset-blocking-in-non' true</br>
            // End of automatics</br>
        end</br>
        else begin</br>
            a &lt;= in_a;</br>
            b  = in_b;</br>
            c &lt;= in_c;</br>
        end</br>
    end
