align-rules-list is a variable defined in `align.el'.<br/>Its value is shown below.<br/><br/>  This variable may be risky if used as a file-local variable.<br/><br/>Documentation:<br/>A list describing all of the available alignment rules.<br/>The format is:<br/><br/>   ((TITLE<br/>     (ATTRIBUTE . VALUE) ...)<br/>    ...)<br/><br/>The following attributes are meaningful:<br/><br/>`regexp'    This required attribute must be either a string describing<br/>	    a regular expression, or a function (described below).<br/>	    For every line within the section that this regular<br/>	    expression matches, the given rule will be applied to that<br/>	    line.  The exclusion rules denote which part(s) of the<br/>	    line should not be modified; the alignment rules cause the<br/>	    identified whitespace group to be contracted/expanded such<br/>	    that the "alignment character" (the character<br/>	    immediately following the identified parenthesis group),<br/>	    occurs in the same column for every line within the<br/>	    alignment section (see `align-region-separate' for a<br/>	    description of how the region is broken up into alignment<br/>	    sections).<br/><br/>	    The `regexp' attribute describes how the text should be<br/>	    treated.  Within this regexp, there must be at least one<br/>	    group of characters (typically whitespace) identified by<br/>	    the special opening and closing parens used in regexp<br/>	    expressions (`\\(' and `\\)') (see the Emacs manual on<br/>	    the syntax of regular expressions for more info).<br/><br/>	    If `regexp' is a function, it will be called as a<br/>	    replacement for `re-search-forward'.  This means that it<br/>	    should return nil if nothing is found to match the rule,<br/>	    or it should set the match data appropriately, move point<br/>	    to the end of the match, and return the value of point.<br/><br/>`group'     For exclusion rules, the group identifies the range of<br/>	    characters that should be ignored.  For alignment rules,<br/>	    these are the characters that will be deleted/expanded for<br/>	    the purposes of alignment.  The "alignment character" is<br/>	    always the first character immediately following this<br/>	    parenthesis group.  This attribute may also be a list of<br/>	    integers, in which case multiple alignment characters will<br/>	    be aligned, with the list of integers identifying the<br/>	    whitespace groups which precede them.  The default for<br/>	    this attribute is 1.<br/><br/>`modes'     The `modes' attribute, if set, should name a list of<br/>	    major modes -- or evaluate to such a value -- in which the<br/>	    rule is valid.  If not set, the rule will apply to all<br/>	    modes.<br/><br/>`case-fold' If `regexp' is an ordinary regular expression string<br/>	    containing alphabetic character, sometimes you may want<br/>	    the search to proceed case-insensitively (for languages<br/>	    that ignore case, such as Pascal for example).  In that<br/>	    case, set `case-fold' to a non-nil value, and the regular<br/>	    expression search will ignore case.  If `regexp' is set to<br/>	    a function, that function must handle the job of ignoring<br/>	    case by itself.<br/><br/>`tab-stop'  If the `tab-stop' attribute is set, and non-nil, the<br/>	    alignment character will always fall on a tab stop<br/>	    (whether it uses tabs to get there or not depends on the<br/>	    value of `indent-tabs-mode').  If the `tab-stop' attribute<br/>	    is set to nil, tab stops will never be used.  Otherwise,<br/>	    the value of `align-to-tab-stop' determines whether or not<br/>	    to align to a tab stop.  The `tab-stop' attribute may also<br/>	    be a list of t or nil values, corresponding to the number<br/>	    of parenthesis groups specified by the `group' attribute.<br/><br/>`repeat'    If the `repeat' attribute is present, and non-nil, the<br/>	    rule will be applied to the line continuously until no<br/>	    further matches are found.<br/><br/>`valid'     If the `valid' attribute is set, it will be used to<br/>	    determine whether the rule should be invoked.  This form<br/>	    is evaluated after the regular expression match has been<br/>	    performed, so that it is possible to use the results of<br/>	    that match to determine whether the alignment should be<br/>	    performed.  The buffer should not be modified during the<br/>	    evaluation of this form.<br/><br/>`run-if'    Like `valid', the `run-if' attribute tests whether the<br/>	    rule should be run at all -- even before any searches are<br/>	    done to determine if the rule applies to the alignment<br/>	    region.  This can save time, since `run-if' will only be<br/>	    run once for each rule.  If it returns nil, the rule will<br/>	    not be attempted.<br/><br/>`column'    For alignment rules, if the `column' attribute is set --<br/>	    which must be an integer, or a symbol whose value is an<br/>	    integer -- it will be used as the column in which to align<br/>	    the alignment character.  If the text on a particular line<br/>	    happens to overrun that column, a single space character,<br/>	    or tab stop (see `align-to-tab-stop') will be added<br/>	    between the last text character and the alignment<br/>	    character.<br/><br/>`spacing'   Alignment rules may also override the amount of spacing<br/>	    that would normally be used by providing a `spacing'<br/>	    attribute.  This must be an integer, or a list of integers<br/>	    corresponding to the number of parenthesis groups matched<br/>	    by the `group' attribute.  If a list of value is used, and<br/>	    any of those values is nil, `align-default-spacing' will<br/>	    be used for that subgroup.  See `align-default-spacing'<br/>	    for more details on spacing, tab stops, and how to<br/>	    indicate how much spacing should be used.  If TAB-STOP is<br/>	    present, it will override the value of `align-to-tab-stop'<br/>	    for that rule.<br/><br/>`justify'   It is possible with `regexp' and `group' to identify a<br/>	    character group that contains more than just whitespace<br/>	    characters.  By default, any non-whitespace characters in<br/>	    that group will also be deleted while aligning the<br/>	    alignment character.  However, if the `justify' attribute<br/>	    is set to a non-nil value, only the initial whitespace<br/>	    characters within that group will be deleted.  This has<br/>	    the effect of right-justifying the characters that remain,<br/>	    and can be used for outdenting or just plain old right-<br/>	    justification.<br/><br/>`separate'  Each rule can define its own section separator, which<br/>	    describes how to identify the separation of "sections"<br/>	    within the region to be aligned.  Setting the `separate'<br/>	    attribute overrides the value of `align-region-separate'<br/>	    (see the documentation of that variable for possible<br/>	    values), and any separation argument passed to `align'.<br/><br/>You can customize this variable.<br/><br/>Value: ((lisp-second-arg<br/>  (regexp . "\\(^\\s-+[^( 	\n]\\|(\\(\\S-+\\)\\s-+\\)\\S-+\\(\\s-+\\)")<br/>  (group . 3)<br/>  (modes . align-lisp-modes)<br/>  (run-if lambda nil current-prefix-arg))<br/> (lisp-alist-dot<br/>  (regexp . "\\(\\s-*\\)\\.\\(\\s-*\\)")<br/>  (group 1 2)<br/>  (modes . align-lisp-modes))<br/> (open-comment<br/>  (regexp lambda<br/>	  (end reverse)<br/>	  (funcall<br/>	   (if reverse 're-search-backward 're-search-forward)<br/>	   (concat "[^ 	\n\\\\]"<br/>		   (regexp-quote comment-start)<br/>		   "\\(.+\\)$")<br/>	   end t))<br/>  (modes . align-open-comment-modes))<br/> (c-macro-definition<br/>  (regexp . "^\\s-*#\\s-*define\\s-+\\S-+\\(\\s-+\\)")<br/>  (modes . align-c++-modes))<br/> (c-variable-declaration<br/>  (regexp . "[*&0-9A-Za-z_]>?[&*]*\\(\\s-+[*&]*\\)[A-Za-z_][0-9A-Za-z:_]*\\s-*\\(\\()\\|=[^=\n].*\\|(.*)\\|\\(\\[.*\\]\\)*\\)?\\s-*[;,]\\|)\\s-*$\\)")<br/>  (group . 1)<br/>  (modes . align-c++-modes)<br/>  (justify . t)<br/>  (valid lambda nil<br/>	 (not<br/>	  (or<br/>	   (save-excursion<br/>	     (goto-char<br/>	      (match-beginning 1))<br/>	     (backward-word 1)<br/>	     (looking-at "\\(goto\\|return\\|new\\|delete\\|throw\\)"))<br/>	   (if<br/>	       (and<br/>		(boundp 'font-lock-mode)<br/>		font-lock-mode)<br/>	       (eq<br/>		(get-text-property<br/>		 (point)<br/>		 'face)<br/>		'font-lock-comment-face)<br/>	     (eq<br/>	      (caar<br/>	       (c-guess-basic-syntax))<br/>	      'c))))))<br/> (c-assignment<br/>  (regexp . "[^-=!^&*+<>/| 	\n]\\(\\s-*[-=!^&*+<>/|]*\\)=\\(\\s-*\\)\\([^= 	\n]\\|$\\)")<br/>  (group 1 2)<br/>  (modes . align-c++-modes)<br/>  (justify . t)<br/>  (tab-stop))<br/> (perl-assignment<br/>  (regexp . "[^=!^&*-+<>/| 	\n]\\(\\s-*\\)=[~>]?\\(\\s-*\\)\\([^>= 	\n]\\|$\\)")<br/>  (group 1 2)<br/>  (modes . align-perl-modes)<br/>  (tab-stop))<br/> (python-assignment<br/>  (regexp . "[^=!<> 	\n]\\(\\s-*\\)=\\(\\s-*\\)\\([^>= 	\n]\\|$\\)")<br/>  (group 1 2)<br/>  (modes quote<br/>	 (python-mode))<br/>  (tab-stop))<br/> (make-assignment<br/>  (regexp . "^\\s-*\\w+\\(\\s-*\\):?=\\(\\s-*\\)\\([^	\n \\\\]\\|$\\)")<br/>  (group 1 2)<br/>  (modes quote<br/>	 (makefile-mode))<br/>  (tab-stop))<br/> (c-comma-delimiter<br/>  (regexp . ",\\(\\s-*\\)[^/ 	\n]")<br/>  (repeat . t)<br/>  (modes . align-c++-modes)<br/>  (run-if lambda nil current-prefix-arg))<br/> (basic-comma-delimiter<br/>  (regexp . ",\\(\\s-*\\)[^# 	\n]")<br/>  (repeat . t)<br/>  (modes append align-perl-modes<br/>	 '(python-mode))<br/>  (run-if lambda nil current-prefix-arg))<br/> (c++-comment<br/>  (regexp . "\\(\\s-*\\)\\(//.*\\|/\\*.*\\*/\\s-*\\)$")<br/>  (modes . align-c++-modes)<br/>  (column . comment-column)<br/>  (valid lambda nil<br/>	 (save-excursion<br/>	   (goto-char<br/>	    (match-beginning 1))<br/>	   (not<br/>	    (bolp)))))<br/> (c-chain-logic<br/>  (regexp . "\\(\\s-*\\)\\(&&\\|||\\|\\<and\\>\\|\\<or\\>\\)")<br/>  (modes . align-c++-modes)<br/>  (valid lambda nil<br/>	 (save-excursion<br/>	   (goto-char<br/>	    (match-end 2))<br/>	   (looking-at "\\s-*\\(/[*/]\\|$\\)"))))<br/> (perl-chain-logic<br/>  (regexp . "\\(\\s-*\\)\\(&&\\|||\\|\\<and\\>\\|\\<or\\>\\)")<br/>  (modes . align-perl-modes)<br/>  (valid lambda nil<br/>	 (save-excursion<br/>	   (goto-char<br/>	    (match-end 2))<br/>	   (looking-at "\\s-*\\(#\\|$\\)"))))<br/> (python-chain-logic<br/>  (regexp . "\\(\\s-*\\)\\(\\<and\\>\\|\\<or\\>\\)")<br/>  (modes quote<br/>	 (python-mode))<br/>  (valid lambda nil<br/>	 (save-excursion<br/>	   (goto-char<br/>	    (match-end 2))<br/>	   (looking-at "\\s-*\\(#\\|$\\|\\\\\\)"))))<br/> (c-macro-line-continuation<br/>  (regexp . "\\(\\s-*\\)\\\\$")<br/>  (modes . align-c++-modes)<br/>  (column . c-backslash-column))<br/> (basic-line-continuation<br/>  (regexp . "\\(\\s-*\\)\\\\$")<br/>  (modes quote<br/>	 (python-mode makefile-mode)))<br/> (tex-record-separator<br/>  (regexp lambda<br/>	  (end reverse)<br/>	  (align-match-tex-pattern "&" end reverse))<br/>  (group 1 2)<br/>  (modes . align-tex-modes)<br/>  (repeat . t))<br/> (tex-tabbing-separator<br/>  (regexp lambda<br/>	  (end reverse)<br/>	  (align-match-tex-pattern "\\\\[=>]" end reverse))<br/>  (group 1 2)<br/>  (modes . align-tex-modes)<br/>  (repeat . t)<br/>  (run-if lambda nil<br/>	  (eq major-mode 'latex-mode)))<br/> (tex-record-break<br/>  (regexp . "\\(\\s-*\\)\\\\\\\\")<br/>  (modes . align-tex-modes))<br/> (text-column<br/>  (regexp . "\\(^\\|\\S-\\)\\([ 	]+\\)\\(\\S-\\|$\\)")<br/>  (group . 2)<br/>  (modes . align-text-modes)<br/>  (repeat . t)<br/>  (run-if lambda nil<br/>	  (and current-prefix-arg<br/>	       (not<br/>		(eq '- current-prefix-arg)))))<br/> (text-dollar-figure<br/>  (regexp . "\\$?\\(\\s-+[0-9]+\\)\\.")<br/>  (modes . align-text-modes)<br/>  (justify . t)<br/>  (run-if lambda nil<br/>	  (eq '- current-prefix-arg)))<br/> (css-declaration<br/>  (regexp . "^\\s-*\\w+:\\(\\s-*\\).*;")<br/>  (group 1)<br/>  (modes quote<br/>	 (css-mode html-mode))))<br/><br/>