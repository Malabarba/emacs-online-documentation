<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head><style type="text/css"> @import url('http://www.gnu.org/software/emacs/manual.css');</style></head><body style="padding:1rem;"><strong>cperl-short-docs</strong> is a variable defined in `<code>cperl-mode.el</code>'.</br>
Its value is <pre>please-ignore-this-line</pre></br>
</br>
<strong id="documentation">Documentation:</strong></br>
# based on '@(#)@ perl-descr.el 1.9 - describe-perl-symbol' [Perl 5]</br>
...	Range (list context); flip/flop [no flop when flip] (scalar context).</br>
! ...	Logical negation.</br>
... != ...	Numeric inequality.</br>
... !~ ...	Search pattern, substitution, or translation (negated).</br>
$!	In numeric context: errno.  In a string context: error string.</br>
$"	The separator which joins elements of arrays interpolated in strings.</br>
$#	The output format for printed numbers.  Default is %.15g or close.</br>
$$	Process number of this script.  Changes in the fork()ed child process.</br>
$%	The current page number of the currently selected output channel.</br>
</br>
	The following variables are always local to the current block:</br>
</br>
$1	Match of the 1st set of parentheses in the last match (auto-local).</br>
$2	Match of the 2nd set of parentheses in the last match (auto-local).</br>
$3	Match of the 3rd set of parentheses in the last match (auto-local).</br>
$4	Match of the 4th set of parentheses in the last match (auto-local).</br>
$5	Match of the 5th set of parentheses in the last match (auto-local).</br>
$6	Match of the 6th set of parentheses in the last match (auto-local).</br>
$7	Match of the 7th set of parentheses in the last match (auto-local).</br>
$8	Match of the 8th set of parentheses in the last match (auto-local).</br>
$9	Match of the 9th set of parentheses in the last match (auto-local).</br>
$&	The string matched by the last pattern match (auto-local).</br>
$'	The string after what was matched by the last match (auto-local).</br>
$`	The string before what was matched by the last match (auto-local).</br>
</br>
$(	The real gid of this process.</br>
$)	The effective gid of this process.</br>
$*	Deprecated: Set to 1 to do multiline matching within a string.</br>
$+	The last bracket matched by the last search pattern.</br>
$,	The output field separator for the print operator.</br>
$-	The number of lines left on the page.</br>
$.	The current input line number of the last filehandle that was read.</br>
$/	The input record separator, newline by default.</br>
$0	Name of the file containing the current perl script (read/write).</br>
$:     String may be broken after these characters to fill ^-lines in a format.</br>
$;	Subscript separator for multi-dim array emulation.  Default "\034".</br>
$<	The real uid of this process.</br>
$=	The page length of the current output channel.  Default is 60 lines.</br>
$>	The effective uid of this process.</br>
$?	The status returned by the last ``, pipe close or `system'.</br>
$@	The perl error message from the last eval or do @var{EXPR} command.</br>
$ARGV	The name of the current file used with <> .</br>
$[	Deprecated: The index of the first element/char in an array/string.</br>
$\	The output record separator for the print operator.</br>
$]	The perl version string as displayed with perl -v.</br>
$^	The name of the current top-of-page format.</br>
$^A     The current value of the write() accumulator for format() lines.</br>
$^D	The value of the perl debug (-D) flags.</br>
$^E     Information about the last system error other than that provided by $!.</br>
$^F	The highest system file descriptor, ordinarily 2.</br>
$^H     The current set of syntax checks enabled by `use strict'.</br>
$^I	The value of the in-place edit extension (perl -i option).</br>
$^L     What formats output to perform a formfeed.  Default is \f.</br>
$^M     A buffer for emergency memory allocation when running out of memory.</br>
$^O     The operating system name under which this copy of Perl was built.</br>
$^P	Internal debugging flag.</br>
$^T	The time the script was started.  Used by -A/-M/-C file tests.</br>
$^W	True if warnings are requested (perl -w flag).</br>
$^X	The name under which perl was invoked (argv[0] in C-speech).</br>
$_	The default input and pattern-searching space.</br>
$|	Auto-flush after write/print on current output channel?  Default 0.</br>
$~	The name of the current report format.</br>
... % ...	Modulo division.</br>
... %= ...	Modulo division assignment.</br>
%ENV	Contains the current environment.</br>
%INC	List of files that have been require-d or do-ne.</br>
%SIG	Used to set signal handlers for various signals.</br>
... & ...	Bitwise and.</br>
... && ...	Logical and.</br>
... &&= ...	Logical and assignment.</br>
... &= ...	Bitwise and assignment.</br>
... * ...	Multiplication.</br>
... ** ...	Exponentiation.</br>
*NAME	Glob: all objects referred by NAME.  *NAM1 = *NAM2 aliases NAM1 to NAM2.</br>
&NAME(arg0, ...)	Subroutine call.  Arguments go to @_.</br>
... + ...	Addition.		+EXPR	Makes EXPR into scalar context.</br>
++	Auto-increment (magical on strings).	++EXPR	EXPR++</br>
... += ...	Addition assignment.</br>
,	Comma operator.</br>
... - ...	Subtraction.</br>
--	Auto-decrement (NOT magical on strings).	--EXPR	EXPR--</br>
... -= ...	Subtraction assignment.</br>
-A	Access time in days since script started.</br>
-B	File is a non-text (binary) file.</br>
-C	Inode change time in days since script started.</br>
-M	Age in days since script started.</br>
-O	File is owned by real uid.</br>
-R	File is readable by real uid.</br>
-S	File is a socket .</br>
-T	File is a text file.</br>
-W	File is writable by real uid.</br>
-X	File is executable by real uid.</br>
-b	File is a block special file.</br>
-c	File is a character special file.</br>
-d	File is a directory.</br>
-e	File exists .</br>
-f	File is a plain file.</br>
-g	File has setgid bit set.</br>
-k	File has sticky bit set.</br>
-l	File is a symbolic link.</br>
-o	File is owned by effective uid.</br>
-p	File is a named pipe (FIFO).</br>
-r	File is readable by effective uid.</br>
-s	File has non-zero size.</br>
-t	Tests if filehandle (STDIN by default) is opened to a tty.</br>
-u	File has setuid bit set.</br>
-w	File is writable by effective uid.</br>
-x	File is executable by effective uid.</br>
-z	File has zero size.</br>
.	Concatenate strings.</br>
..	Range (list context); flip/flop (scalar context) operator.</br>
.=	Concatenate assignment strings</br>
... / ...	Division.	/PATTERN/ioxsmg	Pattern match</br>
... /= ...	Division assignment.</br>
/PATTERN/ioxsmg	Pattern match.</br>
... < ...    Numeric less than.	<pattern>	Glob.	See <NAME>, <> as well.</br>
<NAME>	Reads line from filehandle NAME (a bareword or dollar-bareword).</br>
<pattern>	Glob (Unless pattern is bareword/dollar-bareword - see <NAME>).</br>
<>	Reads line from union of files in @ARGV (= command line) and STDIN.</br>
... << ...	Bitwise shift left.	<<	start of HERE-DOCUMENT.</br>
... <= ...	Numeric less than or equal to.</br>
... <=> ...	Numeric compare.</br>
... = ...	Assignment.</br>
... == ...	Numeric equality.</br>
... =~ ...	Search pattern, substitution, or translation</br>
... > ...	Numeric greater than.</br>
... >= ...	Numeric greater than or equal to.</br>
... >> ...	Bitwise shift right.</br>
... >>= ...	Bitwise shift right assignment.</br>
... ? ... : ...	Condition=if-then-else operator.   ?PAT? One-time pattern match.</br>
?PATTERN?	One-time pattern match.</br>
@ARGV	Command line arguments (not including the command name - see $0).</br>
@INC	List of places to look for perl scripts during do/include/use.</br>
@_    Parameter array for subroutines; result of split() unless in list context.</br>
\  Creates reference to what follows, like \$var, or quotes non-\w in strings.</br>
\0	Octal char, e.g. \033.</br>
\E	Case modification terminator.  See \Q, \L, and \U.</br>
\L	Lowercase until \E .  See also \l, lc.</br>
\U	Upcase until \E .  See also \u, uc.</br>
\Q	Quote metacharacters until \E .  See also quotemeta.</br>
\a	Alarm character (octal 007).</br>
\b	Backspace character (octal 010).</br>
\c	Control character, e.g. \c[ .</br>
\e	Escape character (octal 033).</br>
\f	Formfeed character (octal 014).</br>
\l	Lowercase the next character.  See also \L and \u, lcfirst.</br>
\n	Newline character (octal 012 on most systems).</br>
\r	Return character (octal 015 on most systems).</br>
\t	Tab character (octal 011).</br>
\u	Upcase the next character.  See also \U and \l, ucfirst.</br>
\x	Hex character, e.g. \x1b.</br>
... ^ ...	Bitwise exclusive or.</br>
__END__	Ends program source.</br>
__DATA__	Ends program source.</br>
__FILE__	Current (source) filename.</br>
__LINE__	Current line in current source.</br>
__PACKAGE__	Current package.</br>
ARGV	Default multi-file input filehandle.  <ARGV> is a synonym for <>.</br>
ARGVOUT	Output filehandle with -i flag.</br>
BEGIN { ... }	Immediately executed (during compilation) piece of code.</br>
END { ... }	Pseudo-subroutine executed after the script finishes.</br>
CHECK { ... }	Pseudo-subroutine executed after the script is compiled.</br>
INIT { ... }	Pseudo-subroutine executed before the script starts running.</br>
DATA	Input filehandle for what follows after __END__	or __DATA__.</br>
accept(NEWSOCKET,GENERICSOCKET)</br>
alarm(SECONDS)</br>
atan2(X,Y)</br>
bind(SOCKET,NAME)</br>
binmode(FILEHANDLE)</br>
caller[(LEVEL)]</br>
chdir(EXPR)</br>
chmod(LIST)</br>
chop[(LIST|VAR)]</br>
chown(LIST)</br>
chroot(FILENAME)</br>
close(FILEHANDLE)</br>
closedir(DIRHANDLE)</br>
... cmp ...	String compare.</br>
connect(SOCKET,NAME)</br>
continue of { block } continue { block }.  Is executed after `next' or at end.</br>
cos(EXPR)</br>
crypt(PLAINTEXT,SALT)</br>
dbmclose(%HASH)</br>
dbmopen(%HASH,DBNAME,MODE)</br>
defined(EXPR)</br>
delete($HASH{KEY})</br>
die(LIST)</br>
do { ... }|SUBR while|until EXPR	executes at least once</br>
do(EXPR|SUBR([LIST]))	(with while|until executes at least once)</br>
dump LABEL</br>
each(%HASH)</br>
endgrent</br>
endhostent</br>
endnetent</br>
endprotoent</br>
endpwent</br>
endservent</br>
eof[([FILEHANDLE])]</br>
... eq ...	String equality.</br>
eval(EXPR) or eval { BLOCK }</br>
exec([TRUENAME] ARGV0, ARGVs)     or     exec(SHELL_COMMAND_LINE)</br>
exit(EXPR)</br>
exp(EXPR)</br>
fcntl(FILEHANDLE,FUNCTION,SCALAR)</br>
fileno(FILEHANDLE)</br>
flock(FILEHANDLE,OPERATION)</br>
for (EXPR;EXPR;EXPR) { ... }</br>
foreach [VAR] (@ARRAY) { ... }</br>
fork</br>
... ge ...	String greater than or equal.</br>
getc[(FILEHANDLE)]</br>
getgrent</br>
getgrgid(GID)</br>
getgrnam(NAME)</br>
gethostbyaddr(ADDR,ADDRTYPE)</br>
gethostbyname(NAME)</br>
gethostent</br>
getlogin</br>
getnetbyaddr(ADDR,ADDRTYPE)</br>
getnetbyname(NAME)</br>
getnetent</br>
getpeername(SOCKET)</br>
getpgrp(PID)</br>
getppid</br>
getpriority(WHICH,WHO)</br>
getprotobyname(NAME)</br>
getprotobynumber(NUMBER)</br>
getprotoent</br>
getpwent</br>
getpwnam(NAME)</br>
getpwuid(UID)</br>
getservbyname(NAME,PROTO)</br>
getservbyport(PORT,PROTO)</br>
getservent</br>
getsockname(SOCKET)</br>
getsockopt(SOCKET,LEVEL,OPTNAME)</br>
gmtime(EXPR)</br>
goto LABEL</br>
... gt ...	String greater than.</br>
hex(EXPR)</br>
if (EXPR) { ... } [ elsif (EXPR) { ... } ... ] [ else { ... } ] or EXPR if EXPR</br>
index(STR,SUBSTR[,OFFSET])</br>
int(EXPR)</br>
ioctl(FILEHANDLE,FUNCTION,SCALAR)</br>
join(EXPR,LIST)</br>
keys(%HASH)</br>
kill(LIST)</br>
last [LABEL]</br>
... le ...	String less than or equal.</br>
length(EXPR)</br>
link(OLDFILE,NEWFILE)</br>
listen(SOCKET,QUEUESIZE)</br>
local(LIST)</br>
localtime(EXPR)</br>
log(EXPR)</br>
lstat(EXPR|FILEHANDLE|VAR)</br>
... lt ...	String less than.</br>
m/PATTERN/iogsmx</br>
mkdir(FILENAME,MODE)</br>
msgctl(ID,CMD,ARG)</br>
msgget(KEY,FLAGS)</br>
msgrcv(ID,VAR,SIZE,TYPE.FLAGS)</br>
msgsnd(ID,MSG,FLAGS)</br>
my VAR or my (VAR1,...)	Introduces a lexical variable ($VAR, @ARR, or %HASH).</br>
our VAR or our (VAR1,...) Lexically enable a global variable ($V, @A, or %H).</br>
... ne ...	String inequality.</br>
next [LABEL]</br>
oct(EXPR)</br>
open(FILEHANDLE[,EXPR])</br>
opendir(DIRHANDLE,EXPR)</br>
ord(EXPR)	ASCII value of the first char of the string.</br>
pack(TEMPLATE,LIST)</br>
package NAME	Introduces package context.</br>
pipe(READHANDLE,WRITEHANDLE)	Create a pair of filehandles on ends of a pipe.</br>
pop(ARRAY)</br>
print [FILEHANDLE] [(LIST)]</br>
printf [FILEHANDLE] (FORMAT,LIST)</br>
push(ARRAY,LIST)</br>
q/STRING/	Synonym for 'STRING'</br>
qq/STRING/	Synonym for "STRING"</br>
qx/STRING/	Synonym for `STRING`</br>
rand[(EXPR)]</br>
read(FILEHANDLE,SCALAR,LENGTH[,OFFSET])</br>
readdir(DIRHANDLE)</br>
readlink(EXPR)</br>
recv(SOCKET,SCALAR,LEN,FLAGS)</br>
redo [LABEL]</br>
rename(OLDNAME,NEWNAME)</br>
require [FILENAME | PERL_VERSION]</br>
reset[(EXPR)]</br>
return(LIST)</br>
reverse(LIST)</br>
rewinddir(DIRHANDLE)</br>
rindex(STR,SUBSTR[,OFFSET])</br>
rmdir(FILENAME)</br>
s/PATTERN/REPLACEMENT/gieoxsm</br>
scalar(EXPR)</br>
seek(FILEHANDLE,POSITION,WHENCE)</br>
seekdir(DIRHANDLE,POS)</br>
select(FILEHANDLE | RBITS,WBITS,EBITS,TIMEOUT)</br>
semctl(ID,SEMNUM,CMD,ARG)</br>
semget(KEY,NSEMS,SIZE,FLAGS)</br>
semop(KEY,...)</br>
send(SOCKET,MSG,FLAGS[,TO])</br>
setgrent</br>
sethostent(STAYOPEN)</br>
setnetent(STAYOPEN)</br>
setpgrp(PID,PGRP)</br>
setpriority(WHICH,WHO,PRIORITY)</br>
setprotoent(STAYOPEN)</br>
setpwent</br>
setservent(STAYOPEN)</br>
setsockopt(SOCKET,LEVEL,OPTNAME,OPTVAL)</br>
shift[(ARRAY)]</br>
shmctl(ID,CMD,ARG)</br>
shmget(KEY,SIZE,FLAGS)</br>
shmread(ID,VAR,POS,SIZE)</br>
shmwrite(ID,STRING,POS,SIZE)</br>
shutdown(SOCKET,HOW)</br>
sin(EXPR)</br>
sleep[(EXPR)]</br>
socket(SOCKET,DOMAIN,TYPE,PROTOCOL)</br>
socketpair(SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL)</br>
sort [SUBROUTINE] (LIST)</br>
splice(ARRAY,OFFSET[,LENGTH[,LIST]])</br>
split[(/PATTERN/[,EXPR[,LIMIT]])]</br>
sprintf(FORMAT,LIST)</br>
sqrt(EXPR)</br>
srand(EXPR)</br>
stat(EXPR|FILEHANDLE|VAR)</br>
study[(SCALAR)]</br>
sub [NAME [(format)]] { BODY }	sub NAME [(format)];	sub [(format)] {...}</br>
substr(EXPR,OFFSET[,LEN])</br>
symlink(OLDFILE,NEWFILE)</br>
syscall(LIST)</br>
sysread(FILEHANDLE,SCALAR,LENGTH[,OFFSET])</br>
system([TRUENAME] ARGV0 [,ARGV])     or     system(SHELL_COMMAND_LINE)</br>
syswrite(FILEHANDLE,SCALAR,LENGTH[,OFFSET])</br>
tell[(FILEHANDLE)]</br>
telldir(DIRHANDLE)</br>
time</br>
times</br>
tr/SEARCHLIST/REPLACEMENTLIST/cds</br>
truncate(FILE|EXPR,LENGTH)</br>
umask[(EXPR)]</br>
undef[(EXPR)]</br>
unless (EXPR) { ... } [ else { ... } ] or EXPR unless EXPR</br>
unlink(LIST)</br>
unpack(TEMPLATE,EXPR)</br>
unshift(ARRAY,LIST)</br>
until (EXPR) { ... }					EXPR until EXPR</br>
utime(LIST)</br>
values(%HASH)</br>
vec(EXPR,OFFSET,BITS)</br>
wait</br>
waitpid(PID,FLAGS)</br>
wantarray	Returns true if the sub/eval is called in list context.</br>
warn(LIST)</br>
while  (EXPR) { ... }					EXPR while EXPR</br>
write[(EXPR|FILEHANDLE)]</br>
... x ...	Repeat string or array.</br>
x= ...	Repetition assignment.</br>
y/SEARCHLIST/REPLACEMENTLIST/</br>
... | ...	Bitwise or.</br>
... || ...	Logical or.</br>
~ ...		Unary bitwise complement.</br>
#!	OS interpreter indicator.  If contains `perl', used for options, and -x.</br>
AUTOLOAD {...}	Shorthand for `sub AUTOLOAD {...}'.</br>
CORE::		Prefix to access builtin function if imported sub obscures it.</br>
SUPER::		Prefix to lookup for a method in @ISA classes.</br>
DESTROY		Shorthand for `sub DESTROY {...}'.</br>
... EQ ...	Obsolete synonym of `eq'.</br>
... GE ...	Obsolete synonym of `ge'.</br>
... GT ...	Obsolete synonym of `gt'.</br>
... LE ...	Obsolete synonym of `le'.</br>
... LT ...	Obsolete synonym of `lt'.</br>
... NE ...	Obsolete synonym of `ne'.</br>
abs [ EXPR ]	absolute value</br>
... and ...		Low-precedence synonym for &&.</br>
bless REFERENCE [, PACKAGE]	Makes reference into an object of a package.</br>
chomp [LIST]	Strips $/ off LIST/$_.  Returns count.  Special if $/ eq ''!</br>
chr		Converts a number to char with the same ordinal.</br>
else		Part of if/unless {BLOCK} elsif {BLOCK} else {BLOCK}.</br>
elsif		Part of if/unless {BLOCK} elsif {BLOCK} else {BLOCK}.</br>
exists $HASH{KEY}	True if the key exists.</br>
format [NAME] =	 Start of output format.  Ended by a single dot (.) on a line.</br>
formline PICTURE, LIST	Backdoor into "format" processing.</br>
glob EXPR	Synonym of <EXPR>.</br>
lc [ EXPR ]	Returns lowercased EXPR.</br>
lcfirst [ EXPR ]	Returns EXPR with lower-cased first letter.</br>
grep EXPR,LIST  or grep {BLOCK} LIST	Filters LIST via EXPR/BLOCK.</br>
map EXPR, LIST	or map {BLOCK} LIST	Applies EXPR/BLOCK to elts of LIST.</br>
no PACKAGE [SYMBOL1, ...]  Partial reverse for `use'.  Runs `unimport' method.</br>
not ...		Low-precedence synonym for ! - negation.</br>
... or ...		Low-precedence synonym for ||.</br>
pos STRING    Set/Get end-position of the last match over this string, see \G.</br>
quotemeta [ EXPR ]	Quote regexp metacharacters.</br>
qw/WORD1 .../		Synonym of split('', 'WORD1 ...')</br>
readline FH	Synonym of <FH>.</br>
readpipe CMD	Synonym of `CMD`.</br>
ref [ EXPR ]	Type of EXPR when dereferenced.</br>
sysopen FH, FILENAME, MODE [, PERM]	(MODE is numeric, see Fcntl.)</br>
tie VAR, PACKAGE, LIST	Hide an object behind a simple Perl variable.</br>
tied		Returns internal object for a tied data.</br>
uc [ EXPR ]	Returns upcased EXPR.</br>
ucfirst [ EXPR ]	Returns EXPR with upcased first letter.</br>
untie VAR	Unlink an object from a simple Perl variable.</br>
use PACKAGE [SYMBOL1, ...]  Compile-time `require' with consequent `import'.</br>
... xor ...		Low-precedence synonym for exclusive or.</br>
prototype \&SUB	Returns prototype of the function given a reference.</br>
=head1		Top-level heading.</br>
=head2		Second-level heading.</br>
=head3		Third-level heading (is there such?).</br>
=over [ NUMBER ]	Start list.</br>
=item [ TITLE ]		Start new item in the list.</br>
=back		End list.</br>
=cut		Switch from POD to Perl.</br>
=pod		Switch from Perl to POD.</br>
<br/><br/><br/><br/><small>A courtesy of <a href="http://endlessparentheses.com/">Endless Parentheses</a>. Content under GPL as a part of GNU Emacs.</small></body></html>
