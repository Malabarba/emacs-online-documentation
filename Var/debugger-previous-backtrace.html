debugger-previous-backtrace is a variable defined in `debug.el'.<br/>Its value is shown below.<br/><br/>Documentation:<br/>The contents of the previous backtrace (including text properties).<br/>This is to optimize `debugger-make-xrefs'.<br/><br/>Value: #("Debugger entered--Lisp error: (error \"Command attempted to use minibuffer while in minibuffer\")\n  read-from-minibuffer(\"Switch to buffer (default *scratch*): \" nil (keymap (10 . minibuffer-complete-and-exit) (13 . minibuffer-complete-and-exit) keymap (menu-bar keymap (minibuf \"Minibuf\" keymap (tab menu-item \"Complete\" minibuffer-complete :help \"Complete as far as possible\") (space menu-item \"Complete Word\" minibuffer-complete-word :help \"Complete at most one word\") (63 menu-item \"List Completions\" minibuffer-completion-help :help \"Display all possible completions\") \"Minibuf\")) (27 keymap (118 . switch-to-completions)) (prior . switch-to-completions) (63 . minibuffer-completion-help) (32 . minibuffer-complete-word) (9 . minibuffer-complete) keymap (menu-bar keymap (minibuf \"Minibuf\" keymap (previous menu-item \"Previous History Item\" previous-history-element :help \"Put previous minibuffer history element in the minibuffer\") (next menu-item \"Next History Item\" next-history-element :help \"Put next minibuffer history element in the minibuffer\") (isearch-backward menu-item \"Isearch History Backward\" isearch-backward :help \"Incrementally search minibuffer history backward\") (isearch-forward menu-item \"Isearch History Forward\" isearch-forward :help \"Incrementally search minibuffer history forward\") (return menu-item \"Enter\" exit-minibuffer :key-sequence \"\" :help \"Terminate input and exit minibuffer\") (quit menu-item \"Quit\" abort-recursive-edit :help \"Abort input and exit minibuffer\") \"Minibuf\")) (10 . exit-minibuffer) (13 . exit-minibuffer) (7 . abort-recursive-edit) (C-tab . file-cache-minibuffer-complete) (9 . self-insert-command) (XF86Back . previous-history-element) (up . previous-history-element) (prior . previous-history-element) (XF86Forward . next-history-element) (down . next-history-element) (next . next-history-element) (27 keymap (114 . previous-matching-history-element) (115 . next-matching-history-element) (112 . previous-history-element) (110 . next-history-element))) nil buffer-name-history \"*scratch*\" nil)\n  completing-read-default(\"Switch to buffer (default *scratch*): \" internal-complete-buffer nil confirm-after-completion nil buffer-name-history \"*scratch*\" nil)\n  read-buffer(\"Switch to buffer: \" #<buffer *scratch*> confirm-after-completion)\n  read-buffer-to-switch(\"Switch to buffer: \")\n  (list (read-buffer-to-switch \"Switch to buffer: \") nil (quote force-same-window))\n  call-interactively(switch-to-buffer nil nil)\n  yes-or-no-p(\"Really proceed with writing? \")\n  select-safe-coding-system(1 619 utf-8-unix nil \"/home/artur/Git-Projects/emacs-online-documentation/Fun/hack-local-variables-prop-line.html\")\n  write-region(nil nil \"/home/artur/Git-Projects/emacs-online-documentation/Fun/hack-local-variables-prop-line.html\" nil 0)\n  (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))\n  (with-current-buffer temp-buffer (write-region nil nil temp-file nil 0))\n  (prog1 (with-current-buffer temp-buffer (insert (dth/doc-to-html doc))) (with-current-buffer temp-buffer (write-region nil nil temp-file nil 0)))\n  (unwind-protect (prog1 (with-current-buffer temp-buffer (insert (dth/doc-to-html doc))) (with-current-buffer temp-buffer (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))\n  (let ((temp-file path) (temp-buffer (get-buffer-create (generate-new-buffer-name \" *temp file*\")))) (unwind-protect (prog1 (with-current-buffer temp-buffer (insert (dth/doc-to-html doc))) (with-current-buffer temp-buffer (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer))))\n  (with-temp-file path (insert (dth/doc-to-html doc)))\n  (progn (with-temp-file path (insert (dth/doc-to-html doc))) (add-to-list dth/file-list (cons (symbol-name s) file)))\n  (if doc (progn (with-temp-file path (insert (dth/doc-to-html doc))) (add-to-list dth/file-list (cons (symbol-name s) file))))\n  (when doc (with-temp-file path (insert (dth/doc-to-html doc))) (add-to-list dth/file-list (cons (symbol-name s) file)))\n  (let* ((file (format dth/format (dth/clean-symbol s))) (path (concat dth/dir file)) (doc (condition-case nil (funcall dth/description s) (error nil)))) (when doc (with-temp-file path (insert (dth/doc-to-html doc))) (add-to-list dth/file-list (cons (symbol-name s) file))))\n  dth/symbol-to-file(hack-local-variables-prop-line)\n  mapc(dth/symbol-to-file (gnus-info-rank gnus-info-read gnus-info-score gnus-info-set-entry gnus-info-set-group gnus-info-set-level gnus-info-set-marks gnus-info-set-method gnus-info-set-params gnus-info-set-rank gnus-info-set-read gnus-info-set-score gnus-insert-mime-button gnus-insert-mime-security-button gnus-insert-next-page-button gnus-insert-prev-page-button gnus-insert-random-x-face-header gnus-interactive gnus-intern-safe gnus-intersection gnus-inverse-list-range-intersection gnus-invisible-cut-children gnus-invisible-p gnus-iswitchb-completing-read gnus-jog-cache gnus-key-press-event-p gnus-kill gnus-kill-all-overlays gnus-kill-buffer gnus-kill-ephemeral-group gnus-kill-file-edit-file gnus-kill-file-raise-followups-to-author gnus-kill-gnus-frames gnus-kill-or-deaden-summary gnus-kill-save-kill-buffer gnus-kill-sticky-article-buffer gnus-kill-sticky-article-buffers gnus-killed-articles gnus-last-element gnus-list-debbugs gnus-list-memq-of-list gnus-list-of-read-articles gnus-list-of-unread-articles gnus-list-range-difference gnus-list-range-intersection gnus-load gnus-local-set-keys gnus-long-file-names gnus-lrm-string-p gnus-macroexpand-all ...))\n  (let ((dth/description (quote describe-function)) (dth/format \"Fun/%s.html\") (fill-column 1000) (dth/file-list (quote dth/file-list-function))) (mapc (quote dth/symbol-to-file) (dth/function-list)))\n  dth/convert()\n  eval((dth/convert) nil)\n  eval-last-sexp-1(nil)\n  eval-last-sexp(nil)\n  call-interactively(eval-last-sexp nil nil)\n" 2054 2077<br/>  (button<br/>   (t)<br/>   category help-function-def-button help-args<br/>   (completing-read-default "/usr/share/emacs/24.3/lisp/minibuffer.elc"))<br/>  2297 2318<br/>  (button<br/>   (t)<br/>   category help-function-def-button help-args<br/>   (read-buffer-to-switch "/usr/share/emacs/24.3/lisp/window.elc"))<br/>  2521 2546<br/>  (button<br/>   (t)<br/>   category help-function-def-button help-args<br/>   (select-safe-coding-system "/usr/share/emacs/24.3/lisp/international/mule-cmds.elc"))<br/>  2878 2897<br/>  (button<br/>   (t)<br/>   category help-function-def-button help-args<br/>   (with-current-buffer "/usr/share/emacs/24.3/lisp/subr.elc"))<br/>  3648 3662<br/>  (button<br/>   (t)<br/>   category help-function-def-button help-args<br/>   (with-temp-file "/usr/share/emacs/24.3/lisp/subr.elc"))<br/>  3950 3954<br/>  (button<br/>   (t)<br/>   category help-function-def-button help-args<br/>   (when "/usr/share/emacs/24.3/lisp/subr.elc"))<br/>  4346 4364<br/>  (button<br/>   (t)<br/>   category help-function-def-button help-args<br/>   (dth/symbol-to-file "/home/artur/Dropbox/Scripts/emacs.d/packages/doc-to-html.el"))<br/>  5775 5786<br/>  (help-args<br/>   (dth/convert "/home/artur/Dropbox/Scripts/emacs.d/packages/doc-to-html.el")<br/>   category help-function-def-button button<br/>   (t))<br/>  5817 5833<br/>  (help-args<br/>   (eval-last-sexp-1 "/usr/share/emacs/24.3/lisp/emacs-lisp/lisp-mode.elc")<br/>   category help-function-def-button button<br/>   (t))<br/>  5841 5855<br/>  (help-args<br/>   (eval-last-sexp "/usr/share/emacs/24.3/lisp/emacs-lisp/lisp-mode.elc")<br/>   category help-function-def-button button<br/>   (t)))<br/><br/>