font-lock-keywords is a variable defined in `font-lock.el'.<br/>Its value is shown below.<br/><br/>  This variable may be risky if used as a file-local variable.<br/><br/>Documentation:<br/>A list of the keywords to highlight.<br/>There are two kinds of values: user-level, and compiled.<br/><br/>A user-level keywords list is what a major mode or the user would<br/>set up.  Normally the list would come from `font-lock-defaults'.<br/>through selection of a fontification level and evaluation of any<br/>contained expressions.  You can also alter it by calling<br/>`font-lock-add-keywords' or `font-lock-remove-keywords' with MODE = nil.<br/><br/>Each element in a user-level keywords list should have one of these forms:<br/><br/> MATCHER<br/> (MATCHER . SUBEXP)<br/> (MATCHER . FACENAME)<br/> (MATCHER . HIGHLIGHT)<br/> (MATCHER HIGHLIGHT ...)<br/> (eval . FORM)<br/><br/>where MATCHER can be either the regexp to search for, or the function name to<br/>call to make the search (called with one argument, the limit of the search;<br/>it should return non-nil, move point, and set `match-data' appropriately if<br/>it succeeds; like `re-search-forward' would).<br/>MATCHER regexps can be generated via the function `regexp-opt'.<br/><br/>FORM is an expression, whose value should be a keyword element, evaluated when<br/>the keyword is (first) used in a buffer.  This feature can be used to provide a<br/>keyword that can only be generated when Font Lock mode is actually turned on.<br/><br/>HIGHLIGHT should be either MATCH-HIGHLIGHT or MATCH-ANCHORED.<br/><br/>For highlighting single items, for example each instance of the word "foo",<br/>typically only MATCH-HIGHLIGHT is required.<br/>However, if an item or (typically) items are to be highlighted following the<br/>instance of another item (the anchor), for example each instance of the<br/>word "bar" following the word "anchor" then MATCH-ANCHORED may be required.<br/><br/>MATCH-HIGHLIGHT should be of the form:<br/><br/> (SUBEXP FACENAME [OVERRIDE [LAXMATCH]])<br/><br/>SUBEXP is the number of the subexpression of MATCHER to be highlighted.<br/><br/>FACENAME is an expression whose value is the face name to use.<br/>Instead of a face, FACENAME can evaluate to a property list<br/>of the form (face FACE PROP1 VAL1 PROP2 VAL2 ...)<br/>in which case all the listed text-properties will be set rather than<br/>just FACE.  In such a case, you will most likely want to put those<br/>properties in `font-lock-extra-managed-props' or to override<br/>`font-lock-unfontify-region-function'.<br/><br/>OVERRIDE and LAXMATCH are flags.  If OVERRIDE is t, existing fontification can<br/>be overwritten.  If `keep', only parts not already fontified are highlighted.<br/>If `prepend' or `append', existing fontification is merged with the new, in<br/>which the new or existing fontification, respectively, takes precedence.<br/>If LAXMATCH is non-nil, that means don't signal an error if there is<br/>no match for SUBEXP in MATCHER.<br/><br/>For example, an element of the form highlights (if not already highlighted):<br/><br/> "\\<foo\\>"		discrete occurrences of "foo" in the value of the<br/>			variable `font-lock-keyword-face'.<br/> ("fu\\(bar\\)" . 1)	substring "bar" within all occurrences of "fubar" in<br/>			the value of `font-lock-keyword-face'.<br/> ("fubar" . fubar-face)	Occurrences of "fubar" in the value of `fubar-face'.<br/> ("foo\\|bar" 0 foo-bar-face t)<br/>			occurrences of either "foo" or "bar" in the value<br/>			of `foo-bar-face', even if already highlighted.<br/> (fubar-match 1 fubar-face)<br/>			the first subexpression within all occurrences of<br/>			whatever the function `fubar-match' finds and matches<br/>			in the value of `fubar-face'.<br/><br/>MATCH-ANCHORED should be of the form:<br/><br/> (MATCHER PRE-MATCH-FORM POST-MATCH-FORM MATCH-HIGHLIGHT ...)<br/><br/>where MATCHER is a regexp to search for or the function name to call to make<br/>the search, as for MATCH-HIGHLIGHT above, but with one exception; see below.<br/>PRE-MATCH-FORM and POST-MATCH-FORM are evaluated before the first, and after<br/>the last, instance MATCH-ANCHORED's MATCHER is used.  Therefore they can be<br/>used to initialize before, and cleanup after, MATCHER is used.  Typically,<br/>PRE-MATCH-FORM is used to move to some position relative to the original<br/>MATCHER, before starting with MATCH-ANCHORED's MATCHER.  POST-MATCH-FORM might<br/>be used to move back, before resuming with MATCH-ANCHORED's parent's MATCHER.<br/><br/>For example, an element of the form highlights (if not already highlighted):<br/><br/> ("\\<anchor\\>" (0 anchor-face) ("\\<item\\>" nil nil (0 item-face)))<br/><br/> discrete occurrences of "anchor" in the value of `anchor-face', and subsequent<br/> discrete occurrences of "item" (on the same line) in the value of `item-face'.<br/> (Here PRE-MATCH-FORM and POST-MATCH-FORM are nil.  Therefore "item" is<br/> initially searched for starting from the end of the match of "anchor", and<br/> searching for subsequent instances of "anchor" resumes from where searching<br/> for "item" concluded.)<br/><br/>The above-mentioned exception is as follows.  The limit of the MATCHER search<br/>defaults to the end of the line after PRE-MATCH-FORM is evaluated.<br/>However, if PRE-MATCH-FORM returns a position greater than the position after<br/>PRE-MATCH-FORM is evaluated, that position is used as the limit of the search.<br/>It is generally a bad idea to return a position greater than the end of the<br/>line, i.e., cause the MATCHER search to span lines.<br/><br/>These regular expressions can match text which spans lines, although<br/>it is better to avoid it if possible since updating them while editing<br/>text is slower, and it is not guaranteed to be always correct when using<br/>support modes like jit-lock or lazy-lock.<br/><br/>This variable is set by major modes via the variable `font-lock-defaults'.<br/>Be careful when composing regexps for this list; a poorly written pattern can<br/>dramatically slow things down!<br/><br/>A compiled keywords list starts with t.  It is produced internal<br/>by `font-lock-compile-keywords' from a user-level keywords list.<br/>Its second element is the user-level keywords list that was<br/>compiled.  The remaining elements have the same form as<br/>user-level keywords, but normally their values have been<br/>optimized.<br/><br/>Value: (t<br/> ("\\<table-with-cache-buffer\\>"<br/>  ("(\\(\\(def\\(un\\|macro\\)-mh\\)\\|\\(def\\(custom\\|face\\)-mh\\)\\|\\(defgroup-mh\\)\\)\\>[ 	'(]*\\(setf[ 	]+\\sw+)\\|\\sw+\\)?"<br/>   (1 font-lock-keyword-face)<br/>   (7<br/>    (cond<br/>     ((match-beginning 2)<br/>      font-lock-function-name-face)<br/>     ((match-beginning 4)<br/>      font-lock-variable-name-face)<br/>     (t font-lock-type-face))<br/>    nil t))<br/>  ("(\\(def\\(\\(advice\\|alias\\|generic\\|macro\\*?\\|method\\|setf\\|subst\\*?\\|un\\*?\\|ine-\\(condition\\|\\(?:derived\\|\\(?:global\\(?:ized\\)?-\\)?minor\\|generic\\)-mode\\|method-combination\\|setf-expander\\|skeleton\\|widget\\|function\\|\\(compiler\\|modify\\|symbol\\)-macro\\)\\)\\|\\(const\\(ant\\)?\\|custom\\|varalias\\|face\\|parameter\\|var\\)\\|\\(class\\|group\\|theme\\|package\\|struct\\|type\\)\\)\\)\\>[ 	'(]*\\(setf[ 	]+\\sw+\\|\\sw+\\)?"<br/>   (1 font-lock-keyword-face)<br/>   (9<br/>    (cond<br/>     ((match-beginning 3)<br/>      font-lock-function-name-face)<br/>     ((match-beginning 6)<br/>      font-lock-variable-name-face)<br/>     (t font-lock-type-face))<br/>    nil t))<br/>  ("^;;;###\\([-a-z]*autoload\\)" 1 font-lock-warning-face prepend)<br/>  ("\\[\\(\\^\\)" 1 font-lock-negation-char-face prepend)<br/>  ("(\\(co\\(?:mbine-after-change-calls\\|nd\\(?:ition-case\\(?:-unless-debug\\)?\\)?\\)\\|eval-\\(?:a\\(?:fter-load\\|nd-compile\\)\\|next-after-load\\|when\\(?:-compile\\)?\\)\\|i\\(?:f\\|nline\\)\\|l\\(?:ambda\\|et\\(?:\\*\\|rec\\)?\\)\\|p\\(?:case\\(?:-let\\*?\\)?\\|rog[*12nv]?\\)\\|save-\\(?:current-buffer\\|excursion\\|match-data\\|restriction\\|selected-window\\|window-excursion\\)\\|track-mouse\\|unwind-protect\\|w\\(?:hile\\(?:-no-input\\)?\\|ith-\\(?:c\\(?:a\\(?:\\(?:se\\|tegory\\)-table\\)\\|urrent-buffer\\)\\|demoted-errors\\|electric-help\\|local-quit\\|no-warnings\\|output-to-\\(?:string\\|temp-buffer\\)\\|s\\(?:elected-\\(?:frame\\|window\\)\\|ilent-modifications\\|yntax-table\\)\\|t\\(?:emp-\\(?:buffer\\|\\(?:fil\\|messag\\)e\\)\\|imeout\\(?:-handler\\)?\\)\\|wrapper-hook\\)\\)\\)\\>" . 1)<br/>  ("(\\(b\\(?:\\(?:loc\\|rea\\)k\\)\\|c\\(?:ase\\|case\\|ompiler-let\\|typecase\\)\\|d\\(?:e\\(?:cla\\(?:im\\|re\\)\\|structuring-bind\\)\\|o\\(?:\\*\\|list\\|times\\)?\\)\\|e\\(?:\\(?:type\\)?case\\)\\|flet\\|go\\|handler-\\(?:bind\\|case\\)\\|i\\(?:gnore-errors\\|n-package\\)\\|l\\(?:abels\\|e\\(?:tf\\|xical-let\\*?\\)\\|o\\(?:cally\\|op\\)\\)\\|m\\(?:acrolet\\|ultiple-value-\\(?:bind\\|prog1\\)\\)\\|proclaim\\|re\\(?:start-\\(?:bind\\|case\\)\\|turn\\(?:-from\\)?\\)\\|symbol-macrolet\\|t\\(?:agbody\\|\\(?:h\\|ypecas\\)e\\)\\|unless\\|w\\(?:hen\\|ith-\\(?:accessors\\|co\\(?:mpilation-unit\\|ndition-restarts\\)\\|hash-table-iterator\\|input-from-string\\|o\\(?:pen-\\(?:file\\|stream\\)\\|utput-to-string\\)\\|package-iterator\\|s\\(?:imple-restart\\|lots\\|tandard-io-syntax\\)\\)\\)\\)\\>" . 1)<br/>  ("(\\(catch\\|throw\\|featurep\\|provide\\|require\\)\\>[ 	']*\\(\\sw+\\)?"<br/>   (1 font-lock-keyword-face)<br/>   (2 font-lock-constant-face nil t))<br/>  ("(\\(abort\\|assert\\|warn\\|check-type\\|cerror\\|error\\|signal\\)\\>" 1 font-lock-warning-face)<br/>  ("\\\\\\\\\\[\\(\\sw+\\)\\]" 1 font-lock-constant-face prepend)<br/>  ("`\\(\\sw\\sw+\\)'" 1 font-lock-constant-face prepend)<br/>  ("\\<:\\sw+\\>" 0 font-lock-builtin-face)<br/>  ("\\<\\&\\sw+\\>" . font-lock-type-face)<br/>  ((lambda<br/>     (bound)<br/>     (catch 'found<br/>       (while<br/>	   (re-search-forward "\\(\\\\\\\\\\)\\(?:\\(\\\\\\\\\\)\\|\\((\\(?:\\?[0-9]*:\\)?\\|[|)]\\)\\)" bound t)<br/>	 (unless<br/>	     (match-beginning 2)<br/>	   (let<br/>	       ((face<br/>		 (get-text-property<br/>		  (1-<br/>		   (point))<br/>		  'face)))<br/>	     (when<br/>		 (or<br/>		  (and<br/>		   (listp face)<br/>		   (memq 'font-lock-string-face face))<br/>		  (eq 'font-lock-string-face face))<br/>	       (throw 'found t)))))))<br/>   (1 'font-lock-regexp-grouping-backslash prepend)<br/>   (3 'font-lock-regexp-grouping-construct prepend)))<br/> ("\\<table-with-cache-buffer\\>"<br/>  (0 font-lock-keyword-face))<br/> ("(\\(\\(def\\(un\\|macro\\)-mh\\)\\|\\(def\\(custom\\|face\\)-mh\\)\\|\\(defgroup-mh\\)\\)\\>[ 	'(]*\\(setf[ 	]+\\sw+)\\|\\sw+\\)?"<br/>  (1 font-lock-keyword-face)<br/>  (7<br/>   (cond<br/>    ((match-beginning 2)<br/>     font-lock-function-name-face)<br/>    ((match-beginning 4)<br/>     font-lock-variable-name-face)<br/>    (t font-lock-type-face))<br/>   nil t))<br/> ("(\\(def\\(\\(advice\\|alias\\|generic\\|macro\\*?\\|method\\|setf\\|subst\\*?\\|un\\*?\\|ine-\\(condition\\|\\(?:derived\\|\\(?:global\\(?:ized\\)?-\\)?minor\\|generic\\)-mode\\|method-combination\\|setf-expander\\|skeleton\\|widget\\|function\\|\\(compiler\\|modify\\|symbol\\)-macro\\)\\)\\|\\(const\\(ant\\)?\\|custom\\|varalias\\|face\\|parameter\\|var\\)\\|\\(class\\|group\\|theme\\|package\\|struct\\|type\\)\\)\\)\\>[ 	'(]*\\(setf[ 	]+\\sw+\\|\\sw+\\)?"<br/>  (1 font-lock-keyword-face)<br/>  (9<br/>   (cond<br/>    ((match-beginning 3)<br/>     font-lock-function-name-face)<br/>    ((match-beginning 6)<br/>     font-lock-variable-name-face)<br/>    (t font-lock-type-face))<br/>   nil t))<br/> ("^;;;###\\([-a-z]*autoload\\)"<br/>  (1 font-lock-warning-face prepend))<br/> ("\\[\\(\\^\\)"<br/>  (1 font-lock-negation-char-face prepend))<br/> ("(\\(co\\(?:mbine-after-change-calls\\|nd\\(?:ition-case\\(?:-unless-debug\\)?\\)?\\)\\|eval-\\(?:a\\(?:fter-load\\|nd-compile\\)\\|next-after-load\\|when\\(?:-compile\\)?\\)\\|i\\(?:f\\|nline\\)\\|l\\(?:ambda\\|et\\(?:\\*\\|rec\\)?\\)\\|p\\(?:case\\(?:-let\\*?\\)?\\|rog[*12nv]?\\)\\|save-\\(?:current-buffer\\|excursion\\|match-data\\|restriction\\|selected-window\\|window-excursion\\)\\|track-mouse\\|unwind-protect\\|w\\(?:hile\\(?:-no-input\\)?\\|ith-\\(?:c\\(?:a\\(?:\\(?:se\\|tegory\\)-table\\)\\|urrent-buffer\\)\\|demoted-errors\\|electric-help\\|local-quit\\|no-warnings\\|output-to-\\(?:string\\|temp-buffer\\)\\|s\\(?:elected-\\(?:frame\\|window\\)\\|ilent-modifications\\|yntax-table\\)\\|t\\(?:emp-\\(?:buffer\\|\\(?:fil\\|messag\\)e\\)\\|imeout\\(?:-handler\\)?\\)\\|wrapper-hook\\)\\)\\)\\>"<br/>  (1 font-lock-keyword-face))<br/> ("(\\(b\\(?:\\(?:loc\\|rea\\)k\\)\\|c\\(?:ase\\|case\\|ompiler-let\\|typecase\\)\\|d\\(?:e\\(?:cla\\(?:im\\|re\\)\\|structuring-bind\\)\\|o\\(?:\\*\\|list\\|times\\)?\\)\\|e\\(?:\\(?:type\\)?case\\)\\|flet\\|go\\|handler-\\(?:bind\\|case\\)\\|i\\(?:gnore-errors\\|n-package\\)\\|l\\(?:abels\\|e\\(?:tf\\|xical-let\\*?\\)\\|o\\(?:cally\\|op\\)\\)\\|m\\(?:acrolet\\|ultiple-value-\\(?:bind\\|prog1\\)\\)\\|proclaim\\|re\\(?:start-\\(?:bind\\|case\\)\\|turn\\(?:-from\\)?\\)\\|symbol-macrolet\\|t\\(?:agbody\\|\\(?:h\\|ypecas\\)e\\)\\|unless\\|w\\(?:hen\\|ith-\\(?:accessors\\|co\\(?:mpilation-unit\\|ndition-restarts\\)\\|hash-table-iterator\\|input-from-string\\|o\\(?:pen-\\(?:file\\|stream\\)\\|utput-to-string\\)\\|package-iterator\\|s\\(?:imple-restart\\|lots\\|tandard-io-syntax\\)\\)\\)\\)\\>"<br/>  (1 font-lock-keyword-face))<br/> ("(\\(catch\\|throw\\|featurep\\|provide\\|require\\)\\>[ 	']*\\(\\sw+\\)?"<br/>  (1 font-lock-keyword-face)<br/>  (2 font-lock-constant-face nil t))<br/> ("(\\(abort\\|assert\\|warn\\|check-type\\|cerror\\|error\\|signal\\)\\>"<br/>  (1 font-lock-warning-face))<br/> ("\\\\\\\\\\[\\(\\sw+\\)\\]"<br/>  (1 font-lock-constant-face prepend))<br/> ("`\\(\\sw\\sw+\\)'"<br/>  (1 font-lock-constant-face prepend))<br/> ("\\<:\\sw+\\>"<br/>  (0 font-lock-builtin-face))<br/> ("\\<\\&\\sw+\\>"<br/>  (0 font-lock-type-face))<br/> ((lambda<br/>    (bound)<br/>    (catch 'found<br/>      (while<br/>	  (re-search-forward "\\(\\\\\\\\\\)\\(?:\\(\\\\\\\\\\)\\|\\((\\(?:\\?[0-9]*:\\)?\\|[|)]\\)\\)" bound t)<br/>	(unless<br/>	    (match-beginning 2)<br/>	  (let<br/>	      ((face<br/>		(get-text-property<br/>		 (1-<br/>		  (point))<br/>		 'face)))<br/>	    (when<br/>		(or<br/>		 (and<br/>		  (listp face)<br/>		  (memq 'font-lock-string-face face))<br/>		 (eq 'font-lock-string-face face))<br/>	      (throw 'found t)))))))<br/>  (1 'font-lock-regexp-grouping-backslash prepend)<br/>  (3 'font-lock-regexp-grouping-construct prepend))<br/> ("^\\s("<br/>  (0<br/>   (if<br/>       (memq<br/>	(get-text-property<br/>	 (match-beginning 0)<br/>	 'face)<br/>	'(font-lock-string-face font-lock-doc-face font-lock-comment-face))<br/>       (list 'face font-lock-warning-face 'help-echo "Looks like a toplevel defun: escape the parenthesis"))<br/>   prepend)))<br/><br/>Local in buffer doc-to-html.el; global value is nil<br/>