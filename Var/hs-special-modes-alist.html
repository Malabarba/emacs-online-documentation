---
title: "hs-special-modes-alist"
layout: doc
---
<strong>hs-special-modes-alist</strong> is a variable defined in `<code>hideshow.el</code>'.</br>
Its value is shown <a href="#value">below</a>.</br>
</br>
<strong id="documentation">Documentation:</strong></br>
Alist for initializing the hideshow variables for different modes.</br>
Each element has the form</br>
  (MODE START END COMMENT-START FORWARD-SEXP-FUNC ADJUST-BEG-FUNC).</br>
</br>
If non-nil, hideshow will use these values as regexps to define blocks</br>
and comments, respectively for major mode MODE.</br>
</br>
START, END and COMMENT-START are regular expressions.  A block is</br>
defined as text surrounded by START and END.</br>
</br>
As a special case, START may be a list of the form (COMPLEX-START</br>
MDATA-SELECTOR), where COMPLEX-START is a regexp w/ multiple parts and</br>
MDATA-SELECTOR an integer that specifies which sub-match is the proper</br>
place to adjust point, before calling `hs-forward-sexp-func'.  Point</br>
is adjusted to the beginning of the specified match.  For example,</br>
see the `hs-special-modes-alist' entry for `bibtex-mode'.</br>
</br>
For some major modes, `forward-sexp' does not work properly.  In those</br>
cases, FORWARD-SEXP-FUNC specifies another function to use instead.</br>
</br>
See the documentation for `hs-adjust-block-beginning' to see what is the</br>
use of ADJUST-BEG-FUNC.</br>
</br>
If any of the elements is left nil or omitted, hideshow tries to guess</br>
appropriate values.  The regexps should not contain leading or trailing</br>
whitespace.  Case does not matter.</br>
</br>
<strong id="value">Value:</strong> <pre></br>
((f90-mode "^[ 	0-9]*\\(\\(\\(\\(?:\\sw\\|\\s_\\)+[ 	]*:[ 	]*\\)?\\(do\\|select[ 	]*\\(case\\|type\\)\\|if[ 	]*(\\(.*\\|.*\n\\([^if]*\\([^i].\\|.[^f]\\|.\\_>\\)\\)\\)\\_<then\\|\\(where\\|forall\\)[ 	]*(.*)[ 	]*\\(!\\|$\\)\\)\\)\\|type[ 	,]\\([^i(!\n\"& 	]\\|i[^s!\n\"& 	]\\|is\\(?:\\sw\\|\\s_\\)\\)\\|program\\|\\(?:abstract[ 	]*\\)?interface\\|\\(?:sub\\)?module\\|function\\|subroutine\\|enum[^e]\\|associate\\|block\\|critical\\)[ 	]*" "^[ 	0-9]*\\_<end[ 	]*\\(associate\\|block\\|critical\\|do\\|enum\\|f\\(?:orall\\|unction\\)\\|i\\(?:f\\|nterface\\)\\|module\\|program\\|s\\(?:elect\\|ub\\(?:\\(?:modul\\|routin\\)e\\)\\)\\|\\(?:typ\\|wher\\)e\\)\\_>" "!" f90-end-of-block nil)
 (fortran-mode "^[ 	0-9]*\\(\\(\\(\\sw+[ 	]*:[ 	]*\\)?\\(if[ 	]*(\\(.*\\|.*\n\\([^if]*\\([^i].\\|.[^f]\\|.\\>\\)\\)\\)\\<then\\|do\\|select[ 	]*case\\|where\\)\\)\\|\\(?:function\\|interface\\|map\\|program\\|s\\(?:\\(?:tructur\\|ubroutin\\)e\\)\\|union\\)\\|block[ 	]*data\\)[ 	]*" "^[ 	0-9]*\\<end[ 	]*\\(block[ 	]*data\\|select[ 	]*case\\|\\(?:do\\|function\\|i\\(?:f\\|nterface\\)\\|map\\|program\\|s\\(?:\\(?:tructur\\|ubroutin\\)e\\)\\|union\\|where\\)\\|!\\|$\\)" "^[cC*!]" fortran-end-of-block nil)
 (c-mode "{" "}" "/[*/]" nil nil)
 (c++-mode "{" "}" "/[*/]" nil nil)
 (bibtex-mode
  ("@\\S(*\\(\\s(\\)" 1))
 (java-mode "{" "}" "/[*/]" nil nil)
 (js-mode "{" "}" "/[*/]" nil))
</pre></br>

