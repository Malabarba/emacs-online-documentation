<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head><style type="text/css"> @import url('http://www.gnu.org/software/emacs/manual.css');</style></head><body style="padding:1rem;"><strong>info-lookup-alist</strong> is a variable defined in `<code>info-look.el</code>'.</br>
Its value is shown <a href="#value">below</a>.</br>
</br>
<strong id="documentation">Documentation:</strong></br>
Alist of known help topics.</br>
Cons cells are of the form</br>
</br>
    (HELP-TOPIC . HELP-DATA)</br>
</br>
HELP-TOPIC is the symbol of a help topic.</br>
HELP-DATA is a HELP-TOPIC's public data set.</br>
 Value is an alist with elements of the form</br>
</br>
    (HELP-MODE REGEXP IGNORE-CASE DOC-SPEC PARSE-RULE OTHER-MODES)</br>
</br>
HELP-MODE is a mode's symbol.</br>
REGEXP is a regular expression matching those help items whose</br>
 documentation can be looked up via DOC-SPEC.</br>
IGNORE-CASE is non-nil if help items are case insensitive.</br>
DOC-SPEC is a list of documentation specifications of the form</br>
</br>
    (INFO-NODE TRANS-FUNC PREFIX SUFFIX)</br>
</br>
INFO-NODE is the name (including file name part) of an Info index.</br>
TRANS-FUNC is a function translating index entries into help items;</br>
 nil means add only those index entries matching REGEXP, a string</br>
 means prepend string to the first word of all index entries.</br>
PREFIX and SUFFIX are parts of a regular expression.  If one of</br>
 them is non-nil then search the help item's Info node for the</br>
 first occurrence of the regular expression `PREFIX ITEM SUFFIX'.</br>
 ITEM will be highlighted with `info-lookup-highlight-face' if this</br>
 variable is not nil.</br>
PARSE-RULE is either the symbol name of a function or a regular</br>
 expression for guessing the default help item at point.  Fuzzy</br>
 regular expressions like "[_a-zA-Z0-9]+" do a better job if</br>
 there are no clear delimiters; do not try to write too complex</br>
 expressions.  PARSE-RULE defaults to REGEXP.</br>
OTHER-MODES is a list of cross references to other help modes.</br>
</br>
<strong id="value">Value:</strong> <pre></br>
((file
  (c-mode "[_a-zA-Z0-9./+-]+" nil
	  (("(libc)File Index"))
	  nil nil))
 (symbol
  (help-mode "[^][()`',:\" 	\n]+" nil nil nil
	     (emacs-lisp-mode))
  (Custom-mode "[^][()`',:\" 	\n]+" t nil info-lookup-guess-custom-symbol
	       (emacs-lisp-mode))
  (cfengine-mode "[[:alnum:]_]+\\(?:()\\)?" nil
		 (("(cfengine-Reference)Variable Index"
		   (lambda
		     (item)
		     (if
			 (string-match "\\([[:alnum:]_]+\\)()" item)
			 (match-string 1 item)
		       item))
		   "`" "("))
		 nil nil)
  (sh-mode "\\([a-zA-Z0-9_-]+\\|[!{}@*#?$]\\|\\[\\[?\\|]]?\\)" nil
	   (("(bash)Builtin Index" nil "^`" "[ .']")
	    ("(bash)Reserved Word Index" nil "^`" "[ .']")
	    ("(bash)Variable Index" nil "^`" "[ .']")
	    ("(coreutils)Index"
	     (lambda
	       (item)
	       (if
		   (string-match "\\`[a-z]+\\'" item)
		   item)))
	    ("(coreutils)Concept Index"
	     (lambda
	       (item)
	       (if
		   (string-match "\\`[a-z]+\\'" item)
		   item)))
	    ("(diff)Index"
	     (lambda
	       (item)
	       (if
		   (string-match "\\`\\([a-z]+\\) invocation\\'" item)
		   (match-string 1 item))))
	    ("(sed)Concept Index"
	     (lambda
	       (item)
	       (if
		   (string-equal item "Standard input, processing as input")
		   "sed")))
	    ("(gawk)Index"
	     (lambda
	       (item)
	       (cond
		((string-equal item "gawk, extensions, disabling")
		 "awk")
		((string-equal item "gawk, versions of, information about, printing")
		 "gawk")))))
	   nil nil)
  (inferior-maxima-mode "[a-zA-Z0-9_%]+" nil nil nil
			(maxima-mode))
  (maxima-mode "[a-zA-Z0-9_%]+" t
	       (("(maxima)Function and Variable Index" nil "^ -+ [^:]+:[ ]+\\(\\[[^=]*=[ ]+\\)?" nil))
	       nil nil)
  (octave-mode "[_a-zA-Z0-9]+\\|\\s.+\\|[-!=^|*/.\\,><~&+]\\{1,3\\}\\|[][();,\"']" nil
	       (("(octave)Function Index" nil "^ -+ [^:]+:[ ]+\\(\\[[^=]*=[ ]+\\)?" nil)
		("(octave)Variable Index" nil "^ -+ [^:]+:[ ]+" nil)
		("(octave)Operator Index" nil nil nil)
		("(octave)Concept Index"
		 (lambda
		   (item)
		   (cond
		    ((string-match "^\\([A-Z]+\\) statement\\b" item)
		     (match-string 1 item))
		    (t nil)))
		 nil nil))
	       nil nil)
  (scheme-mode "[^()`',\" 	\n]+" t
	       (("(r5rs)Index" nil "^[ 	]+-+ [^:]+:[ 	]*" "\\b"))
	       nil nil)
  (lisp-mode "[^()`',\" 	\n]+" nil nil ignore
	     (emacs-lisp-mode))
  (lisp-interaction-mode "[^][()`',\" 	\n]+" nil nil ignore
			 (emacs-lisp-mode))
  (apropos-mode "[^][()`',\" 	\n]+" nil nil nil
		(emacs-lisp-mode))
  (emacs-lisp-mode "[^][()`',\" 	\n]+" nil
		   (("(emacs)Command Index" nil "`\\(M-x[ 	\n]+\\)?" "'")
		    ("(emacs)Variable Index" nil "`" "'")
		    ("(elisp)Index" nil "^ -+ .*: " "\\( \\|$\\)"))
		   nil nil)
  (latex-mode "\\\\\\([a-zA-Z]+\\|[^a-zA-Z]\\)" nil
	      (("(latex)Command Index" nil "`" "\\({[^}]*}\\)?'"))
	      nil nil)
  (cperl-mode "[$@%][^a-zA-Z]\\|\\$\\^[A-Z]\\|[$@%]?[a-zA-Z][_a-zA-Z0-9]*" nil nil nil
	      (perl-mode))
  (perl-mode "[$@%][^a-zA-Z]\\|\\$\\^[A-Z]\\|[$@%]?[a-zA-Z][_a-zA-Z0-9]*" nil
	     (("(perl5)Function Index"
	       (lambda
		 (item)
		 (if
		     (string-match "^\\([a-zA-Z0-9]+\\)" item)
		     (match-string 1 item)))
	       "^" "\\b")
	      ("(perl5)Variable Index"
	       (lambda
		 (item)
		 (let
		     ((sym
		       (cond
			((or
			  (string-match "^\\$\\(.\\|@@\\)$" item)
			  (string-match "^\\$\\^[A-Z]$" item))
			 item)
			((string-match "^\\([$%@]\\|@@\\)?[_a-zA-Z0-9]+" item)
			 (match-string 0 item))
			(t ""))))
		   (if
		       (string-match "@@" sym)
		       (setq sym
			     (concat
			      (substring sym 0
					 (match-beginning 0))
			      (substring sym
					 (1-
					  (match-end 0))))))
		   (if
		       (string-equal sym "")
		       nil sym)))
	       "^" "\\b"))
	     "[$@%]?\\([_a-zA-Z0-9]+\\|[^a-zA-Z]\\)" nil)
  (awk-mode "[_a-zA-Z]+" nil
	    (("(gawk)Index"
	      (lambda
		(item)
		(let
		    ((case-fold-search nil))
		  (cond
		   ((string-match "^\\([A-Z]+\\) special pattern\\b" item)
		    (match-string 1 item))
		   ((string-match "^\\([a-z]+\\) statement\\b" item)
		    (if
			(not
			 (string-equal
			  (match-string 1 item)
			  "control"))
			(match-string 1 item)))
		   ((string-match "^[A-Z]+$" item)
		    item)
		   ((string-match "^[a-z]+$" item)
		    item))))
	      "`" "\\([ 	]*([^)]*)\\)?'"))
	    nil nil)
  (autoconf-mode "A[CM]_[_A-Z0-9]+" nil
		 (("(autoconf)Autoconf Macro Index"
		   (lambda
		     (item)
		     (if
			 (string-match "^A._" item)
			 item
		       (concat "AC_" item)))
		   "^[ 	]+-+ \\(Macro\\|Variable\\): .*\\<" "\\>")
		  ("(autoconf)M4 Macro Index"
		   (lambda
		     (item)
		     (let
			 ((case-fold-search nil))
		       (cond
			((or
			  (string-equal item "dnl")
			  (string-match "^m4_" item)
			  (string-match "^AS_" item))
			 item)
			((string-match "^[A-Z0-9_]+$" item)
			 (concat "AS_" item))
			(t
			 (concat "m4_" item)))))
		   "^[ 	]+-+ Macro: .*\\<" "\\>")
		  ("(autoconf)Autotest Macro Index" "AT_" "^[ 	]+-+ Macro: .*\\<" "\\>")
		  ("(autoconf)Macro Index" "AC_" "^[ 	]+-+ \\(Macro\\|Variable\\): .*\\<" "\\>")
		  ("(automake)Macro and Variable Index" nil "^[ 	]*`" "'"))
		 ignore
		 (m4-mode))
  (m4-mode "[_a-zA-Z][_a-zA-Z0-9]*" nil
	   (("(m4)Macro index"))
	   "[_a-zA-Z0-9]+" nil)
  (texinfo-mode "@\\([a-zA-Z]+\\|[^a-zA-Z]\\)" nil
		(("(texinfo)Command and Variable Index"
		  (lambda
		    (item)
		    (if
			(string-match "^\\([a-zA-Z]+\\|[^a-zA-Z]\\)\\( .*\\)?$" item)
			(concat "@"
				(match-string 1 item))))
		  "`" "[' ]"))
		nil nil)
  (makefile-automake-mode "\\$[^({]\\|\\.[_A-Z]*\\|[_a-zA-Z][_a-zA-Z0-9-]*\\|##\\|\\+=" nil
			  (("(automake)Variable Index" nil "^[ 	]*`" "'")
			   ("(automake)Macro and Variable Index" nil "^[ 	]*`" "'")
			   ("(automake)General Index" nil "`" "'")
			   ("(automake)Index" nil "`" "'"))
			  "\\$[^({]\\|\\.[_A-Z]*\\|[_a-zA-Z0-9-]+\\|##\\|\\+="
			  (makefile-mode))
  (makefile-mode "\\$[^({]\\|\\.[_A-Z]*\\|[_a-zA-Z][_a-zA-Z0-9-]*" nil
		 (("(make)Name Index" nil "^[ 	]*`" "'"))
		 "\\$[^({]\\|\\.[_A-Z]*\\|[_a-zA-Z0-9-]+" nil)
  (bison-mode "[:;|]\\|%\\([%{}]\\|[_a-z]+\\)\\|YY[_A-Z]+\\|yy[_a-z]+" nil
	      (("(bison)Index" nil "`" "'"))
	      "[:;|]\\|%\\([%{}]\\|[_a-zA-Z][_a-zA-Z0-9]*\\)"
	      (c-mode))
  (c-mode "\\(struct \\|union \\|enum \\)?[_a-zA-Z][_a-zA-Z0-9]*" nil
	  (("(libc)Function Index" nil "^[ 	]+-+ \\(Function\\|Macro\\): .*\\<" "\\>")
	   ("(libc)Variable Index" nil "^\\([ 	]+-+ \\(Variable\\|Macro\\): .*\\<\\|`\\)" "\\( \\|'?$\\)")
	   ("(libc)Type Index" nil "^[ 	]+-+ Data Type: \\<" "\\>")
	   ("(termcap)Var Index" nil "^[ 	]*`" "'"))
	  info-lookup-guess-c-symbol nil)))
</pre></br>
<br/><br/><br/><br/><small>A courtesy of <a href="http://endlessparentheses.com/">Endless Parentheses</a>. Content under GPL as a part of GNU Emacs.</small></body></html>
