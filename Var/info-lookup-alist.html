info-lookup-alist is a variable defined in `info-look.el'.<br/>Its value is shown below.<br/><br/>Documentation:<br/>Alist of known help topics.<br/>Cons cells are of the form<br/><br/>    (HELP-TOPIC . HELP-DATA)<br/><br/>HELP-TOPIC is the symbol of a help topic.<br/>HELP-DATA is a HELP-TOPIC's public data set.<br/> Value is an alist with elements of the form<br/><br/>    (HELP-MODE REGEXP IGNORE-CASE DOC-SPEC PARSE-RULE OTHER-MODES)<br/><br/>HELP-MODE is a mode's symbol.<br/>REGEXP is a regular expression matching those help items whose<br/> documentation can be looked up via DOC-SPEC.<br/>IGNORE-CASE is non-nil if help items are case insensitive.<br/>DOC-SPEC is a list of documentation specifications of the form<br/><br/>    (INFO-NODE TRANS-FUNC PREFIX SUFFIX)<br/><br/>INFO-NODE is the name (including file name part) of an Info index.<br/>TRANS-FUNC is a function translating index entries into help items;<br/> nil means add only those index entries matching REGEXP, a string<br/> means prepend string to the first word of all index entries.<br/>PREFIX and SUFFIX are parts of a regular expression.  If one of<br/> them is non-nil then search the help item's Info node for the<br/> first occurrence of the regular expression `PREFIX ITEM SUFFIX'.<br/> ITEM will be highlighted with `info-lookup-highlight-face' if this<br/> variable is not nil.<br/>PARSE-RULE is either the symbol name of a function or a regular<br/> expression for guessing the default help item at point.  Fuzzy<br/> regular expressions like "[_a-zA-Z0-9]+" do a better job if<br/> there are no clear delimiters; do not try to write too complex<br/> expressions.  PARSE-RULE defaults to REGEXP.<br/>OTHER-MODES is a list of cross references to other help modes.<br/><br/>Value: ((file<br/>  (c-mode "[_a-zA-Z0-9./+-]+" nil<br/>	  (("(libc)File Index"))<br/>	  nil nil))<br/> (symbol<br/>  (help-mode "[^][()`',:\" 	\n]+" nil nil nil<br/>	     (emacs-lisp-mode))<br/>  (Custom-mode "[^][()`',:\" 	\n]+" t nil info-lookup-guess-custom-symbol<br/>	       (emacs-lisp-mode))<br/>  (cfengine-mode "[[:alnum:]_]+\\(?:()\\)?" nil<br/>		 (("(cfengine-Reference)Variable Index"<br/>		   (lambda<br/>		     (item)<br/>		     (if<br/>			 (string-match "\\([[:alnum:]_]+\\)()" item)<br/>			 (match-string 1 item)<br/>		       item))<br/>		   "`" "("))<br/>		 nil nil)<br/>  (sh-mode "\\([a-zA-Z0-9_-]+\\|[!{}@*#?$]\\|\\[\\[?\\|]]?\\)" nil<br/>	   (("(bash)Builtin Index" nil "^`" "[ .']")<br/>	    ("(bash)Reserved Word Index" nil "^`" "[ .']")<br/>	    ("(bash)Variable Index" nil "^`" "[ .']")<br/>	    ("(coreutils)Index"<br/>	     (lambda<br/>	       (item)<br/>	       (if<br/>		   (string-match "\\`[a-z]+\\'" item)<br/>		   item)))<br/>	    ("(coreutils)Concept Index"<br/>	     (lambda<br/>	       (item)<br/>	       (if<br/>		   (string-match "\\`[a-z]+\\'" item)<br/>		   item)))<br/>	    ("(diff)Index"<br/>	     (lambda<br/>	       (item)<br/>	       (if<br/>		   (string-match "\\`\\([a-z]+\\) invocation\\'" item)<br/>		   (match-string 1 item))))<br/>	    ("(sed)Concept Index"<br/>	     (lambda<br/>	       (item)<br/>	       (if<br/>		   (string-equal item "Standard input, processing as input")<br/>		   "sed")))<br/>	    ("(gawk)Index"<br/>	     (lambda<br/>	       (item)<br/>	       (cond<br/>		((string-equal item "gawk, extensions, disabling")<br/>		 "awk")<br/>		((string-equal item "gawk, versions of, information about, printing")<br/>		 "gawk")))))<br/>	   nil nil)<br/>  (inferior-maxima-mode "[a-zA-Z0-9_%]+" nil nil nil<br/>			(maxima-mode))<br/>  (maxima-mode "[a-zA-Z0-9_%]+" t<br/>	       (("(maxima)Function and Variable Index" nil "^ -+ [^:]+:[ ]+\\(\\[[^=]*=[ ]+\\)?" nil))<br/>	       nil nil)<br/>  (octave-mode "[_a-zA-Z0-9]+\\|\\s.+\\|[-!=^|*/.\\,><~&+]\\{1,3\\}\\|[][();,\"']" nil<br/>	       (("(octave)Function Index" nil "^ -+ [^:]+:[ ]+\\(\\[[^=]*=[ ]+\\)?" nil)<br/>		("(octave)Variable Index" nil "^ -+ [^:]+:[ ]+" nil)<br/>		("(octave)Operator Index" nil nil nil)<br/>		("(octave)Concept Index"<br/>		 (lambda<br/>		   (item)<br/>		   (cond<br/>		    ((string-match "^\\([A-Z]+\\) statement\\b" item)<br/>		     (match-string 1 item))<br/>		    (t nil)))<br/>		 nil nil))<br/>	       nil nil)<br/>  (scheme-mode "[^()`',\" 	\n]+" t<br/>	       (("(r5rs)Index" nil "^[ 	]+-+ [^:]+:[ 	]*" "\\b"))<br/>	       nil nil)<br/>  (lisp-mode "[^()`',\" 	\n]+" nil nil ignore<br/>	     (emacs-lisp-mode))<br/>  (lisp-interaction-mode "[^][()`',\" 	\n]+" nil nil ignore<br/>			 (emacs-lisp-mode))<br/>  (apropos-mode "[^][()`',\" 	\n]+" nil nil nil<br/>		(emacs-lisp-mode))<br/>  (emacs-lisp-mode "[^][()`',\" 	\n]+" nil<br/>		   (("(emacs)Command Index" nil "`\\(M-x[ 	\n]+\\)?" "'")<br/>		    ("(emacs)Variable Index" nil "`" "'")<br/>		    ("(elisp)Index" nil "^ -+ .*: " "\\( \\|$\\)"))<br/>		   nil nil)<br/>  (latex-mode "\\\\\\([a-zA-Z]+\\|[^a-zA-Z]\\)" nil<br/>	      (("(latex)Command Index" nil "`" "\\({[^}]*}\\)?'"))<br/>	      nil nil)<br/>  (cperl-mode "[$@%][^a-zA-Z]\\|\\$\\^[A-Z]\\|[$@%]?[a-zA-Z][_a-zA-Z0-9]*" nil nil nil<br/>	      (perl-mode))<br/>  (perl-mode "[$@%][^a-zA-Z]\\|\\$\\^[A-Z]\\|[$@%]?[a-zA-Z][_a-zA-Z0-9]*" nil<br/>	     (("(perl5)Function Index"<br/>	       (lambda<br/>		 (item)<br/>		 (if<br/>		     (string-match "^\\([a-zA-Z0-9]+\\)" item)<br/>		     (match-string 1 item)))<br/>	       "^" "\\b")<br/>	      ("(perl5)Variable Index"<br/>	       (lambda<br/>		 (item)<br/>		 (let<br/>		     ((sym<br/>		       (cond<br/>			((or<br/>			  (string-match "^\\$\\(.\\|@@\\)$" item)<br/>			  (string-match "^\\$\\^[A-Z]$" item))<br/>			 item)<br/>			((string-match "^\\([$%@]\\|@@\\)?[_a-zA-Z0-9]+" item)<br/>			 (match-string 0 item))<br/>			(t ""))))<br/>		   (if<br/>		       (string-match "@@" sym)<br/>		       (setq sym<br/>			     (concat<br/>			      (substring sym 0<br/>					 (match-beginning 0))<br/>			      (substring sym<br/>					 (1-<br/>					  (match-end 0))))))<br/>		   (if<br/>		       (string-equal sym "")<br/>		       nil sym)))<br/>	       "^" "\\b"))<br/>	     "[$@%]?\\([_a-zA-Z0-9]+\\|[^a-zA-Z]\\)" nil)<br/>  (awk-mode "[_a-zA-Z]+" nil<br/>	    (("(gawk)Index"<br/>	      (lambda<br/>		(item)<br/>		(let<br/>		    ((case-fold-search nil))<br/>		  (cond<br/>		   ((string-match "^\\([A-Z]+\\) special pattern\\b" item)<br/>		    (match-string 1 item))<br/>		   ((string-match "^\\([a-z]+\\) statement\\b" item)<br/>		    (if<br/>			(not<br/>			 (string-equal<br/>			  (match-string 1 item)<br/>			  "control"))<br/>			(match-string 1 item)))<br/>		   ((string-match "^[A-Z]+$" item)<br/>		    item)<br/>		   ((string-match "^[a-z]+$" item)<br/>		    item))))<br/>	      "`" "\\([ 	]*([^)]*)\\)?'"))<br/>	    nil nil)<br/>  (autoconf-mode "A[CM]_[_A-Z0-9]+" nil<br/>		 (("(autoconf)Autoconf Macro Index"<br/>		   (lambda<br/>		     (item)<br/>		     (if<br/>			 (string-match "^A._" item)<br/>			 item<br/>		       (concat "AC_" item)))<br/>		   "^[ 	]+-+ \\(Macro\\|Variable\\): .*\\<" "\\>")<br/>		  ("(autoconf)M4 Macro Index"<br/>		   (lambda<br/>		     (item)<br/>		     (let<br/>			 ((case-fold-search nil))<br/>		       (cond<br/>			((or<br/>			  (string-equal item "dnl")<br/>			  (string-match "^m4_" item)<br/>			  (string-match "^AS_" item))<br/>			 item)<br/>			((string-match "^[A-Z0-9_]+$" item)<br/>			 (concat "AS_" item))<br/>			(t<br/>			 (concat "m4_" item)))))<br/>		   "^[ 	]+-+ Macro: .*\\<" "\\>")<br/>		  ("(autoconf)Autotest Macro Index" "AT_" "^[ 	]+-+ Macro: .*\\<" "\\>")<br/>		  ("(autoconf)Macro Index" "AC_" "^[ 	]+-+ \\(Macro\\|Variable\\): .*\\<" "\\>")<br/>		  ("(automake)Macro and Variable Index" nil "^[ 	]*`" "'"))<br/>		 ignore<br/>		 (m4-mode))<br/>  (m4-mode "[_a-zA-Z][_a-zA-Z0-9]*" nil<br/>	   (("(m4)Macro index"))<br/>	   "[_a-zA-Z0-9]+" nil)<br/>  (texinfo-mode "@\\([a-zA-Z]+\\|[^a-zA-Z]\\)" nil<br/>		(("(texinfo)Command and Variable Index"<br/>		  (lambda<br/>		    (item)<br/>		    (if<br/>			(string-match "^\\([a-zA-Z]+\\|[^a-zA-Z]\\)\\( .*\\)?$" item)<br/>			(concat "@"<br/>				(match-string 1 item))))<br/>		  "`" "[' ]"))<br/>		nil nil)<br/>  (makefile-automake-mode "\\$[^({]\\|\\.[_A-Z]*\\|[_a-zA-Z][_a-zA-Z0-9-]*\\|##\\|\\+=" nil<br/>			  (("(automake)Variable Index" nil "^[ 	]*`" "'")<br/>			   ("(automake)Macro and Variable Index" nil "^[ 	]*`" "'")<br/>			   ("(automake)General Index" nil "`" "'")<br/>			   ("(automake)Index" nil "`" "'"))<br/>			  "\\$[^({]\\|\\.[_A-Z]*\\|[_a-zA-Z0-9-]+\\|##\\|\\+="<br/>			  (makefile-mode))<br/>  (makefile-mode "\\$[^({]\\|\\.[_A-Z]*\\|[_a-zA-Z][_a-zA-Z0-9-]*" nil<br/>		 (("(make)Name Index" nil "^[ 	]*`" "'"))<br/>		 "\\$[^({]\\|\\.[_A-Z]*\\|[_a-zA-Z0-9-]+" nil)<br/>  (bison-mode "[:;|]\\|%\\([%{}]\\|[_a-z]+\\)\\|YY[_A-Z]+\\|yy[_a-z]+" nil<br/>	      (("(bison)Index" nil "`" "'"))<br/>	      "[:;|]\\|%\\([%{}]\\|[_a-zA-Z][_a-zA-Z0-9]*\\)"<br/>	      (c-mode))<br/>  (c-mode "\\(struct \\|union \\|enum \\)?[_a-zA-Z][_a-zA-Z0-9]*" nil<br/>	  (("(libc)Function Index" nil "^[ 	]+-+ \\(Function\\|Macro\\): .*\\<" "\\>")<br/>	   ("(libc)Variable Index" nil "^\\([ 	]+-+ \\(Variable\\|Macro\\): .*\\<\\|`\\)" "\\( \\|'?$\\)")<br/>	   ("(libc)Type Index" nil "^[ 	]+-+ Data Type: \\<" "\\>")<br/>	   ("(termcap)Var Index" nil "^[ 	]*`" "'"))<br/>	  info-lookup-guess-c-symbol nil)))<br/><br/>