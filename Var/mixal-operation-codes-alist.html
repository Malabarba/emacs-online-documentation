<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head><style type="text/css"> @import url('http://www.gnu.org/software/emacs/manual.css');</style></head><body style="padding:1rem;"><strong>mixal-operation-codes-alist</strong> is a variable defined in `<code>mixal-mode.el</code>'.</br>
Its value is shown <a href="#value">below</a>.</br>
</br>
<strong id="documentation">Documentation:</strong></br>
Alist that contains all the possible operation codes for mix.</br>
Each elt has the form</br>
  (OP-CODE GROUP FULL-NAME C-BYTE F-BYTE DESCRIPTION EXECUTION-TIME)</br>
Where OP-CODE is the text of the opcode as a symbol,</br>
FULL-NAME is the human readable name as a string,</br>
C-BYTE is the operation code telling what operation is to be performed,</br>
F-BYTE holds a modification of the operation code which can be a symbol</br>
  or a number,</br>
DESCRIPTION contains an string with a description about the operation code and</br>
EXECUTION-TIME holds info about the time it takes, number or string.</br>
</br>
<strong id="value">Value:</strong> <pre></br>
((LDA loading "load A" 8 field "Put in rA the contents of cell no. M.\nUses a + when there is no sign in subfield. Subfield is left padded with\nzeros to make a word." 2)
 (LDX loading "load X" 15 field "Put in rX the contents of cell no. M.\nUses a + when there is no sign in subfield. Subfield is left padded with\nzeros to make a word." 2)
 (LD1 loading "load I1" 9 field "Put in rI1 the contents of cell no. M.\nUses a + when there is no sign in subfield. Subfield is left padded with\nzeros to make a word. Index registers only have 2 bytes and a sign; trying\nto set anything more than that will result in undefined behavior." 2)
 (LD2 loading "load I2" 10 field "Put in rI2 the contents of cell no. M.\nUses a + when there is no sign in subfield. Subfield is left padded with\nzeros to make a word. Index registers only have 2 bytes and a sign; trying\nto set anything more than that will result in undefined behavior." 2)
 (LD3 loading "load I3" 11 field "Put in rI3 the contents of cell no. M.\nUses a + when there is no sign in subfield. Subfield is left padded with\nzeros to make a word. Index registers only have 2 bytes and a sign; trying\nto set anything more than that will result in undefined behavior." 2)
 (LD4 loading "load I4" 12 field "Put in rI4 the contents of cell no. M.\nUses a + when there is no sign in subfield. Subfield is left padded with\nzeros to make a word. Index registers only have 2 bytes and a sign; trying\nto set anything more than that will result in undefined behavior." 2)
 (LD5 loading "load I5" 13 field "Put in rI5 the contents of cell no. M.\nUses a + when there is no sign in subfield. Subfield is left padded with\nzeros to make a word. Index registers only have 2 bytes and a sign; trying\nto set anything more than that will result in undefined behavior." 2)
 (LD6 loading "load I6" 14 field "Put in rI6 the contents of cell no. M.\nUses a + when there is no sign in subfield. Subfield is left padded with\nzeros to make a word. Index registers only have 2 bytes and a sign; trying\nto set anything more than that will result in undefined behavior." 2)
 (LDAN loading "load A negative" 16 field "Put in rA the contents of cell no. M, with opposite sign.\nUses a + when there is no sign in subfield, otherwise use the opposite sign.\nSubfield is left padded with zeros to make a word." 2)
 (LDXN loading "load X negative" 23 field "Put in rX the contents of cell no. M, with opposite sign.\nUses a + when there is no sign in subfield, otherwise use the opposite sign.\nSubfield is left padded with zeros to make a word." 2)
 (LD1N loading "load I1 negative" 17 field "Put in rI1 the contents of cell no. M, with opposite sign.\nUses a + when there is no sign in subfield, otherwise use the opposite sign.\nSubfield is left padded with zeros to make a word. Index registers only\nhave 2 bytes and a sign; trying to set anything more than that will result\nin undefined behavior." 2)
 (LD2N loading "load I2 negative" 18 field "Put in rI2 the contents of cell no. M, with opposite sign.\nUses a + when there is no sign in subfield, otherwise use the opposite sign.\nSubfield is left padded with zeros to make a word. Index registers only\nhave 2 bytes and a sign; trying to set anything more than that will result\nin undefined behavior." 2)
 (LD3N loading "load I3 negative" 19 field "Put in rI3 the contents of cell no. M, with opposite sign.\nUses a + when there is no sign in subfield, otherwise use the opposite sign.\nSubfield is left padded with zeros to make a word. Index registers only\nhave 2 bytes and a sign; trying to set anything more than that will result\nin undefined behavior." 2)
 (LD4N loading "load I4 negative" 20 field "Put in rI4 the contents of cell no. M, with opposite sign.\nUses a + when there is no sign in subfield, otherwise use the opposite sign.\nSubfield is left padded with zeros to make a word. Index registers only\nhave 2 bytes and a sign; trying to set anything more than that will result\nin undefined behavior." 2)
 (LD5N loading "load I5 negative" 21 field "Put in rI5 the contents of cell no. M, with opposite sign.\nUses a + when there is no sign in subfield, otherwise use the opposite sign.\nSubfield is left padded with zeros to make a word. Index registers only\nhave 2 bytes and a sign; trying to set anything more than that will result\nin undefined behavior." 2)
 (LD6N loading "load I6 negative" 22 field "Put in rI6 the contents of cell no. M, with opposite sign.\nUses a + when there is no sign in subfield, otherwise use the opposite sign.\nSubfield is left padded with zeros to make a word. Index registers only\nhave 2 bytes and a sign; trying to set anything more than that will result\nin undefined behavior." 2)
 (STA storing "store A" 24 field "Store in cell Nr. M the contents of rA.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with bytes from a register. These\nbytes are taken beginning by the rightmost side of the register. The\nsign of the memory cell is not changed, unless it is part of the subfield." 2)
 (STX storing "store X" 31 field "Store in cell Nr. M the contents of rX.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with bytes from a register. These\nbytes are taken beginning by the rightmost side of the register. The\nsign of the memory cell is not changed, unless it is part of the subfield." 2)
 (ST1 storing "store I1" 25 field "Store in cell Nr. M the contents of rI1.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with bytes from a register. These\nbytes are taken beginning by the rightmost side of the register. The\nsign of the memory cell is not changed, unless it is part of the subfield.\nBecause index registers only have 2 bytes and a sign, the rest of the bytes\nare assumed to be 0." 2)
 (ST2 storing "store I2" 26 field "Store in cell Nr. M the contents of rI2.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with bytes from a register. These\nbytes are taken beginning by the rightmost side of the register. The\nsign of the memory cell is not changed, unless it is part of the subfield.\nBecause index registers only have 2 bytes and a sign, the rest of the bytes\nare assumed to be 0." 2)
 (ST3 storing "store I3" 27 field "Store in cell Nr. M the contents of rI3.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with bytes from a register. These\nbytes are taken beginning by the rightmost side of the register. The\nsign of the memory cell is not changed, unless it is part of the subfield.\nBecause index registers only have 2 bytes and a sign, the rest of the bytes\nare assumed to be 0." 2)
 (ST4 storing "store I4" 28 field "Store in cell Nr. M the contents of rI4.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with bytes from a register. These\nbytes are taken beginning by the rightmost side of the register. The\nsign of the memory cell is not changed, unless it is part of the subfield.\nBecause index registers only have 2 bytes and a sign, the rest of the bytes\nare assumed to be 0." 2)
 (ST5 storing "store I5" 29 field "Store in cell Nr. M the contents of rI5.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with bytes from a register. These\nbytes are taken beginning by the rightmost side of the register. The\nsign of the memory cell is not changed, unless it is part of the subfield.\nBecause index registers only have 2 bytes and a sign, the rest of the bytes\nare assumed to be 0." 2)
 (ST6 storing "store I6" 30 field "Store in cell Nr. M the contents of rI6.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with bytes from a register. These\nbytes are taken beginning by the rightmost side of the register. The\nsign of the memory cell is not changed, unless it is part of the subfield.\nBecause index registers only have 2 bytes and a sign, the rest of the bytes\nare assumed to be 0." 2)
 (STJ storing "store J" 32 field "Store in cell Nr. M the contents of rJ.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with bytes from a register. These\nbytes are taken beginning by the rightmost side of the register. The sign\nof rJ is always +, sign of the memory cell is not changed, unless it is\npart of the subfield. The default field for STJ is (0:2)." 2)
 (STZ storing "store zero" 33 field "Store in cell Nr. M '+ 0'.\nThe modification of the operation code represents the subfield of the\nmemory cell that is to be overwritten with zeros." 2)
 (ADD arithmetic "add" 1 field "Add to A the contents of cell Nr. M.\nSubfield is padded with zero to make a word.\nIf the result is to large, the operation result modulo 1,073,741,823 (the\nmaximum value storable in a MIX word) is stored in `rA', and the overflow\ntoggle is set to TRUE." 2)
 (SUB arithmetic "subtract" 2 field "Subtract to A the contents of cell Nr. M.\nSubfield is padded with zero to make a word.\nIf the result is to large, the operation result modulo 1,073,741,823 (the\nmaximum value storable in a MIX word) is stored in `rA', and the overflow\ntoggle is set to TRUE." 2)
 (MUL arithmetic "multiply" 3 field "Multiplies the contents of cell Nr. M with A, result is 10 bytes and stored in rA and rX.\nThe sign is + if the sign of rA and cell M where the same, otherwise, it is -" 10)
 (DIV arithmetic "divide" 4 field "Both rA and rX are taken together and divided by cell Nr. M, quotient is placed in rA, remainder in rX.\nThe sign is taken from rA, and after the divide the sign of rA is set to + when\nboth the sign of rA and M where the same. Divide by zero and overflow of rA\nresult in undefined behavior." 12)
 (ENTA address-transfer "enter A" 48 "Literal value is stored in rA.\nIndexed, stores value of index in rA." 1)
 (ENTX address-transfer "enter X" 55 "Literal value is stored in rX.\nIndexed, stores value of index in rX." 1)
 (ENT1 address-transfer "Enter rI1" 49 "Literal value is stored in rI1.\nIndexed, stores value of index in rI1." 1)
 (ENT2 address-transfer "Enter rI2" 50 "Literal value is stored in rI2.\nIndexed, stores value of index in rI2." 1)
 (ENT3 address-transfer "Enter rI3" 51 "Literal value is stored in rI3.\nIndexed, stores value of index in rI3." 1)
 (ENT4 address-transfer "Enter rI4" 52 "Literal value is stored in rI4.\nIndexed, stores value of index in rI4." 1)
 (ENT5 address-transfer "Enter rI5" 53 "Literal value is stored in rI5.\nIndexed, stores value of index in rI5." 1)
 (ENT6 address-transfer "Enter rI6" 54 "Literal value is stored in rI6.\nIndexed, stores value of index in rI6." 1)
 (ENNA address-transfer "enter negative A" 48 "Literal value is stored in rA with opposite sign.\nIndexed, stores value of index in rA with opposite sign." 1)
 (ENNX address-transfer "enter negative X" 55 "Literal value is stored in rX with opposite sign.\nIndexed, stores value of index in rX with opposite sign." 1)
 (ENN1 address-transfer "Enter negative rI1" 49 "Literal value is stored in rI1 with opposite sign.\nIndexed, stores value of index in rI1 with opposite sign." 1)
 (ENN2 address-transfer "Enter negative rI2" 50 "Literal value is stored in rI2 with opposite sign.\nIndexed, stores value of index in rI2 with opposite sign." 1)
 (ENN3 address-transfer "Enter negative rI3" 51 "Literal value is stored in rI3 with opposite sign.\nIndexed, stores value of index in rI3 with opposite sign." 1)
 (ENN4 address-transfer "Enter negative rI4" 52 "Literal value is stored in rI4 with opposite sign.\nIndexed, stores value of index in rI4 with opposite sign." 1)
 (ENN5 address-transfer "Enter negative rI5" 53 "Literal value is stored in rI5 with opposite sign.\nIndexed, stores value of index in rI5 with opposite sign." 1)
 (ENN6 address-transfer "Enter negative rI6" 54 "Literal value is stored in rI6 with opposite sign.\nIndexed, stores value of index in rI6 with opposite sign." 1)
 (INCA address-transfer "increase A" 48 "Increase register A with the literal value of M.\nOn overflow the overflow toggle is set." 1)
 (INCX address-transfer "increase X" 55 "Increase register X with the literal value of M.\nOn overflow the overflow toggle is set." 1)
 (INC1 address-transfer "increase I1" 49 "Increase register I1 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (INC2 address-transfer "increase I2" 50 "Increase register I2 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (INC3 address-transfer "increase I3" 51 "Increase register I3 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (INC4 address-transfer "increase I4" 52 "Increase register I4 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (INC5 address-transfer "increase I5" 53 "Increase register I5 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (INC6 address-transfer "increase I6" 54 "Increase register I6 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (DECA address-transfer "decrease A" 48 "Decrease register A with the literal value of M.\nOn overflow the overflow toggle is set." 1)
 (DECX address-transfer "decrease X" 55 "Decrease register X with the literal value of M.\nOn overflow the overflow toggle is set." 1)
 (DEC1 address-transfer "decrease I1" 49 "Decrease register I1 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (DEC2 address-transfer "decrease I2" 50 "Decrease register I2 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (DEC3 address-transfer "decrease I3" 51 "Decrease register I3 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (DEC4 address-transfer "decrease I4" 52 "Decrease register I4 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (DEC5 address-transfer "decrease I5" 53 "Decrease register I5 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (DEC6 address-transfer "decrease I6" 54 "Decrease register I6 with the literal value of M.\nThe result is undefined when the result does not fit in\n2 bytes." 1)
 (CMPA comparison "compare A" 56 field "Compare contents of A with contents of M.\nThe field specifier works on both fields. The comparison indicator\nis set to LESS, EQUAL or GREATER depending on the outcome." 2)
 (CMPX comparison "compare X" 63 field "Compare contents of rX with contents of M.\nThe field specifier works on both fields. The comparison indicator\nis set to LESS, EQUAL or GREATER depending on the outcome." 2)
 (CMP1 comparison "compare I1" 57 field "Compare contents of rI1 with contents of M.\nThe field specifier works on both fields. The comparison indicator\nis set to LESS, EQUAL or GREATER depending on the outcome. Bit 1,2 and 3\nhave a value of 0." 2)
 (CMP2 comparison "compare I2" 58 field "Compare contents of rI2 with contents of M.\nThe field specifier works on both fields. The comparison indicator\nis set to LESS, EQUAL or GREATER depending on the outcome. Bit 1,2 and 3\nhave a value of 0." 2)
 (CMP3 comparison "compare I3" 59 field "Compare contents of rI3 with contents of M.\nThe field specifier works on both fields. The comparison indicator\nis set to LESS, EQUAL or GREATER depending on the outcome. Bit 1,2 and 3\nhave a value of 0." 2)
 (CMP4 comparison "compare I4" 60 field "Compare contents of rI4 with contents of M.\nThe field specifier works on both fields. The comparison indicator\nis set to LESS, EQUAL or GREATER depending on the outcome. Bit 1,2 and 3\nhave a value of 0." 2)
 (CMP5 comparison "compare I5" 61 field "Compare contents of rI5 with contents of M.\nThe field specifier works on both fields. The comparison indicator\nis set to LESS, EQUAL or GREATER depending on the outcome. Bit 1,2 and 3\nhave a value of 0." 2)
 (CMP6 comparison "compare I6" 62 field "Compare contents of rI6 with contents of M.\nThe field specifier works on both fields. The comparison indicator\nis set to LESS, EQUAL or GREATER depending on the outcome. Bit 1,2 and 3\nhave a value of 0." 2)
 (JMP jump "jump" 39 "Unconditional jump.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JSJ jump "jump, save J" 39 "Unconditional jump, but rJ is not modified." 1)
 (JOV jump "jump on overflow" 39 "Jump if OV is set (and turn it off).\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JNOV jump "Jump on no overflow" 39 "Jump if OV is not set (and turn it off).\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JL jump "Jump on less" 39 "Jump if '[CM] = L'.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JE jump "Jump on equal" 39 "Jump if '[CM] = E'.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JG jump "Jump on greater" 39 "Jump if '[CM] = G'.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JGE jump "Jump on not less" 39 "Jump if '[CM]' does not equal 'L'.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JNE jump "Jump on not equal" 39 "Jump if '[CM]' does not equal 'E'.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JLE jump "Jump on not greater" 39 "Jump if '[CM]' does not equal 'G'.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JAN jump "jump A negative" 40 "Jump if the content of rA is negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JAZ jump "jump A zero" 40 "Jump if the content of rA is zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JAP jump "jump A positive" 40 "Jump if the content of rA is positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JANN jump "jump A non-negative" 40 "Jump if the content of rA is non-negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JANZ jump "jump A non-zero" 40 "Jump if the content of rA is non-zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JANP jump "jump A non-positive" 40 "Jump if the content of rA is non-positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JXN jump "jump X negative" 47 "Jump if the content of rX is negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JXZ jump "jump X zero" 47 "Jump if the content of rX is zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JXP jump "jump X positive" 47 "Jump if the content of rX is positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JXNN jump "jump X non-negative" 47 "Jump if the content of rX is non-negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JXNZ jump "jump X non-zero" 47 "Jump if the content of rX is non-zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (JXNP jump "jump X non-positive" 47 "Jump if the content of rX is non-positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J1N jump "jump I1 negative" 41 "Jump if the content of rI1 is negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J1Z jump "jump I1 zero" 41 "Jump if the content of rI1 is zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J1P jump "jump I1 positive" 41 "Jump if the content of rI1 is positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J1NN jump "jump I1 non-negative" 41 "Jump if the content of rI1 is non-negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J1NZ jump "jump I1 non-zero" 41 "Jump if the content of rI1 is non-zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J1NP jump "jump I1 non-positive" 41 "Jump if the content of rI1 is non-positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J2N jump "jump I2 negative" 41 "Jump if the content of rI2 is negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J2Z jump "jump I2 zero" 41 "Jump if the content of rI2 is zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J2P jump "jump I2 positive" 41 "Jump if the content of rI2 is positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J2NN jump "jump I2 non-negative" 41 "Jump if the content of rI2 is non-negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J2NZ jump "jump I2 non-zero" 41 "Jump if the content of rI2 is non-zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J2NP jump "jump I2 non-positive" 41 "Jump if the content of rI2 is non-positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J3N jump "jump I3 negative" 41 "Jump if the content of rI3 is negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J3Z jump "jump I3 zero" 41 "Jump if the content of rI3 is zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J3P jump "jump I3 positive" 41 "Jump if the content of rI3 is positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J3NN jump "jump I3 non-negative" 41 "Jump if the content of rI3 is non-negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J3NZ jump "jump I3 non-zero" 41 "Jump if the content of rI3 is non-zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J3NP jump "jump I3 non-positive" 41 "Jump if the content of rI3 is non-positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J4N jump "jump I4 negative" 41 "Jump if the content of rI4 is negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J4Z jump "jump I4 zero" 41 "Jump if the content of rI4 is zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J4P jump "jump I4 positive" 41 "Jump if the content of rI4 is positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J4NN jump "jump I4 non-negative" 41 "Jump if the content of rI4 is non-negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J4NZ jump "jump I4 non-zero" 41 "Jump if the content of rI4 is non-zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J4NP jump "jump I4 non-positive" 41 "Jump if the content of rI4 is non-positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J5N jump "jump I5 negative" 41 "Jump if the content of rI5 is negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J5Z jump "jump I5 zero" 41 "Jump if the content of rI5 is zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J5P jump "jump I5 positive" 41 "Jump if the content of rI5 is positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J5NN jump "jump I5 non-negative" 41 "Jump if the content of rI5 is non-negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J5NZ jump "jump I5 non-zero" 41 "Jump if the content of rI5 is non-zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J5NP jump "jump I5 non-positive" 41 "Jump if the content of rI5 is non-positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J6N jump "jump I6 negative" 41 "Jump if the content of rI6 is negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J6Z jump "jump I6 zero" 41 "Jump if the content of rI6 is zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J6P jump "jump I6 positive" 41 "Jump if the content of rI6 is positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J6NN jump "jump I6 non-negative" 41 "Jump if the content of rI6 is non-negative.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J6NZ jump "jump I6 non-zero" 41 "Jump if the content of rI6 is non-zero.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (J6NP jump "jump I6 non-positive" 41 "Jump if the content of rI6 is non-positive.\nRegister J is set to the value of the next instruction that would have\nbeen executed when there was no jump." 1)
 (SLA miscellaneous "shift left A" 6 "Shift to A, M bytes left.\nHero's will be added to the right." 2)
 (SRA miscellaneous "shift right A" 6 "Shift to A, M bytes right.\nZeros will be added to the left." 2)
 (SLAX miscellaneous "shift left AX" 6 "Shift AX, M bytes left.\nZeros will be added to the right." 2)
 (SRAX miscellaneous "shift right AX" 6 "Shift AX, M bytes right.\nZeros will be added to the left." 2)
 (SLC miscellaneous "shift left AX circularly" 6 "Shift AX, M bytes left circularly.\nThe bytes that fall off to the left will be added to the right." 2)
 (SRC miscellaneous "shift right AX circularly" 6 "Shift AX, M bytes right circularly.\nThe bytes that fall off to the right will be added to the left." 2)
 (MOVE miscellaneous "move" 7 number "Move MOD words from M to the location stored in rI1."
       (+ 1
	  (* 2 number)))
 (NOP miscellaneous "no operation" 0 ignored "No operation, M and F are not used by the machine." 1)
 (HLT miscellaneous "halt" 5 "Halt.\nStop instruction fetching." 1)
 (IN input-output "input" 36 unit "Transfer a block of words from the specified unit to memory.\nThe transfer starts at address M." 1)
 (OUT input-output "output" 37 unit "Transfer a block of words from memory.\nThe transfer starts at address M to the specified unit." 1)
 (IOC input-output "input-output control" 35 unit "Perform a control operation.\nThe control operation is given by M on the specified unit." 1)
 (JRED input-output "jump ready" 38 unit "Jump to M if the specified unit is ready." 1)
 (JBUS input-output "jump busy" 34 unit "Jump to M if the specified unit is busy." 1)
 (NUM conversion "convert to numeric" 5 "Convert rAX to its numerical value and store it in rA.\nthe register rAX is assumed to contain a character representation of\na number." 10)
 (CHAR conversion "convert to characters" 5 "Convert the number stored in rA to a character representation.\nThe converted character representation is stored in rAX." 10))
</pre></br>
<br/><br/><br/><br/><small>A courtesy of <a href="http://endlessparentheses.com/">Endless Parentheses</a>.</small></body></html>
