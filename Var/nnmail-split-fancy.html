<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head><style type="text/css"> @import url('http://www.gnu.org/software/emacs/manual.css');</style></head><body style="padding:1rem;"><strong>nnmail-split-fancy</strong> is a variable defined in `<code>nnmail.el</code>'.</br>
Its value is <pre>"mail.misc"</pre></br>
</br>
<strong id="documentation">Documentation:</strong></br>
Incoming mail can be split according to this fancy variable.</br>
To enable this, set `nnmail-split-methods' to `nnmail-split-fancy'.</br>
</br>
The format of this variable is SPLIT, where SPLIT can be one of</br>
the following:</br>
</br>
GROUP: Mail will be stored in GROUP (a string).</br>
</br>
(FIELD VALUE [- RESTRICT [- RESTRICT [...]]] SPLIT): If the message</br>
  field FIELD (a regexp) contains VALUE (a regexp), store the messages</br>
  as specified by SPLIT.  If RESTRICT (a regexp) matches some string</br>
  after FIELD and before the end of the matched VALUE, return nil,</br>
  otherwise process SPLIT.  Multiple RESTRICTs add up, further</br>
  restricting the possibility of processing SPLIT.</br>
</br>
(| SPLIT...): Process each SPLIT expression until one of them matches.</br>
  A SPLIT expression is said to match if it will cause the mail</br>
  message to be stored in one or more groups.</br>
</br>
(& SPLIT...): Process each SPLIT expression.</br>
</br>
(: FUNCTION optional args): Call FUNCTION with the optional args, in</br>
  the buffer containing the message headers.  The return value FUNCTION</br>
  should be a split, which is then recursively processed.</br>
</br>
(! FUNCTION SPLIT): Call FUNCTION with the result of SPLIT.  The</br>
  return value FUNCTION should be a split, which is then recursively</br>
  processed.</br>
</br>
junk: Mail will be deleted.  Use with care!  Do not submerge in water!</br>
  Example:</br>
  (setq nnmail-split-fancy</br>
	'(| ("Subject" "MAKE MONEY FAST" junk)</br>
	    ...other.rules.omitted...))</br>
</br>
FIELD must match a complete field name.  VALUE must match a complete</br>
word according to the `nnmail-split-fancy-syntax-table' syntax table.</br>
You can use ".*" in the regexps to match partial field names or words.</br>
</br>
FIELD and VALUE can also be Lisp symbols, in that case they are expanded</br>
as specified in `nnmail-split-abbrev-alist'.</br>
</br>
GROUP can contain \& and \N which will substitute from matching</br>
\(\) patterns in the previous VALUE.</br>
</br>
Example:</br>
</br>
(setq nnmail-split-methods 'nnmail-split-fancy</br>
      nnmail-split-fancy</br>
      ;; Messages from the mailer daemon are not crossposted to any of</br>
      ;; the ordinary groups.  Warnings are put in a separate group</br>
      ;; from real errors.</br>
      '(| ("from" mail (| ("subject" "warn.*" "mail.warning")</br>
			  "mail.misc"))</br>
	  ;; Non-error messages are crossposted to all relevant</br>
	  ;; groups, but we don't crosspost between the group for the</br>
	  ;; (ding) list and the group for other (ding) related mail.</br>
	  (& (| (any "ding@ifi\\.uio\\.no" "ding.list")</br>
		("subject" "ding" "ding.misc"))</br>
	     ;; Other mailing lists...</br>
	     (any "procmail@informatik\\.rwth-aachen\\.de" "procmail.list")</br>
	     (any "SmartList@informatik\\.rwth-aachen\\.de" "SmartList.list")</br>
	     ;; Both lists below have the same suffix, so prevent</br>
	     ;; cross-posting to mkpkg.list of messages posted only to</br>
	     ;; the bugs- list, but allow cross-posting when the</br>
	     ;; message was really cross-posted.</br>
	     (any "bugs-mypackage@somewhere" "mypkg.bugs")</br>
	     (any "mypackage@somewhere" - "bugs-mypackage" "mypkg.list")</br>
	     ;;</br>
	     ;; People...</br>
	     (any "larsi@ifi\\.uio\\.no" "people.Lars Magne Ingebrigtsen"))</br>
	  ;; Unmatched mail goes to the catch all group.</br>
	  "misc.misc"))</br>
</br>
You can customize this variable.<br/><br/><br/><br/><small>A courtesy of <a href="http://endlessparentheses.com/">Endless Parentheses</a>.</small></body></html>
